<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>聊城市排污权交易系统开发复盘——初次真实项目实践总结</title>
      <link href="/2025/02/14/%E8%81%8A%E5%9F%8E%E5%B8%82%E6%8E%92%E6%B1%A1%E6%9D%83%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%98%E2%80%94%E2%80%94%E5%88%9D%E6%AC%A1%E7%9C%9F%E5%AE%9E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2025/02/14/%E8%81%8A%E5%9F%8E%E5%B8%82%E6%8E%92%E6%B1%A1%E6%9D%83%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%98%E2%80%94%E2%80%94%E5%88%9D%E6%AC%A1%E7%9C%9F%E5%AE%9E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实验室的带领下，我有幸投身于聊城市排污权交易工作管理系统的后端开发项目。初涉真实项目开发领域，我在编码过程中，既察觉到自身代码风格与实际工程要求存在的差距，又收获了珍贵的工程实战经验。接下来，我将从团队协作和代码实践这两个角度，对这段经历展开总结。</p><hr><h2 id="一、团队协作实践"><a href="#一、团队协作实践" class="headerlink" title="一、团队协作实践"></a>一、团队协作实践</h2><h3 id="1-Git协作流程规范化"><a href="#1-Git协作流程规范化" class="headerlink" title="1. Git协作流程规范化"></a>1. Git协作流程规范化</h3><p>在独立开发中，我常采用单分支提交模式。参与真实项目后，深刻认识到版本控制的重要性：</p><ul><li><strong>提交规范</strong>：遵循规范提交，Commit Message 应遵循 <a href="https://link.juejin.cn/?target=https://www.conventionalcommits.org/en/v1.0.0/%23summary" title="https://www.conventionalcommits.org/en/v1.0.0/#summary">Conventional commits 规范</a><ul><li>规范化的提交信息使代码审查效率提升，并能快速定位功能变更历史。</li><li><a href="https://juejin.cn/post/7145400078939717645?searchId=20241115215259C594FDA0970C9AE527BB">Git 实践规范分享Git 有许多优势，目前是许多团队(唯一使用的代码版本控制软件，为了让大家更加方便、规范地使用 Gi - 掘金</a> git规范参考，每次的commit应该是可以独立完整运行的版本</li></ul></li></ul><h3 id="2-工程化开发工具"><a href="#2-工程化开发工具" class="headerlink" title="2. 工程化开发工具"></a>2. 工程化开发工具</h3><p>使用coding工具</p><ul><li>项目协同</li><li>代码托管</li><li>持续集成</li><li>持续部署<br>每次合并新分支到主分支能够自动检测分析代码，并且部署相应环境，前端能够拿到对应的swagger接口，进行调试</li></ul><hr><h2 id="二、代码开发实践"><a href="#二、代码开发实践" class="headerlink" title="二、代码开发实践"></a>二、代码开发实践</h2><h3 id="1-框架应用"><a href="#1-框架应用" class="headerlink" title="1. 框架应用"></a>1. 框架应用</h3><p>在此之前，使用过ruoyi框架搭建我的项目的后台，见到项目使用yudao进行开发，拉下代码的时候不会感到陌生</p><h3 id="2-分层思想"><a href="#2-分层思想" class="headerlink" title="2.分层思想"></a>2.分层思想</h3><p>自己独立开发，为了图方便，经常将业务代码放在控制层，控制层需要引入多个不同类型的bean可读性较差，后期维护困难<br>本次项目严格要求分层，controller-&gt;service-&gt;mapper<br>我发现，mapper层继承的并不是Mybatisplus生成的BaseMapper，而是yudao再次进行封装的BaseMapperX<br>这主要是</p><ul><li>在 MyBatis Plus 的 BaseMapper 的基础上拓展，提供更多的能力  </li><li></li><li><ol><li>{@link BaseMapper} 为 MyBatis Plus 的基础接口，提供基础的 CRUD 能力</li></ol></li><li><ol start="2"><li>{@link MPJBaseMapper} 为 MyBatis Plus Join 的基础接口，提供连表 Join 能力</li></ol></li></ul><h3 id="3-类型转换规范"><a href="#3-类型转换规范" class="headerlink" title="3. 类型转换规范"></a>3. 类型转换规范</h3><p>项目明令禁止在业务层使用BeanUtils.copyProperties()，强制要求：</p><ul><li>定义专用Converter类实现DTO&#x2F;VO转换</li><li>复杂对象采用MapStruct自动生成转换器</li><li>转换逻辑必须显式声明字段映射关系<br>一开始并不是很理解，后来查阅资料发现许多弊端：<strong>类型不一致导致拷贝失败、null值覆盖、导包冲突、浅拷贝特性及低效的反射实现等问题</strong>‌‌</li></ul><p>为了避免这些问题，使用以下替代方案：</p><ul><li>‌手动赋值‌：通过手动编写getter和setter方法进行赋值，虽然工作量大，但可以精确控制每个字段的赋值过程。</li><li>‌使用MapStruct工具提供了更灵活且高效的映射机制，支持复杂的映射规则，并且避免了反射带来的性能问题。</li></ul><h3 id="4-地区数据加载"><a href="#4-地区数据加载" class="headerlink" title="4. 地区数据加载"></a>4. 地区数据加载</h3><p>在遇到需要根据地区编号查询地区名称的时候：<br>我以为的方案，在数据库中查询地区编码和对应的地区名称<br>实际上：</p><ol><li>提前编写对应的csv（逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。）静态文件</li><li>项目读取对应的文件，使用map存储在内存中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">AreaUtils</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">    areas = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    areas.put(Area.ID_GLOBAL, <span class="keyword">new</span> <span class="title class_">Area</span>(Area.ID_GLOBAL, <span class="string">&quot;全球&quot;</span>, <span class="number">0</span>,  </span><br><span class="line">            <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));  </span><br><span class="line">    <span class="comment">// 从 csv 中加载数据  </span></span><br><span class="line">    List&lt;CsvRow&gt; rows = CsvUtil.getReader().read(ResourceUtil.getUtf8Reader(<span class="string">&quot;area.csv&quot;</span>)).getRows();  </span><br><span class="line">    rows.remove(<span class="number">0</span>); <span class="comment">// 删除 header    for (CsvRow row : rows) &#123;  </span></span><br><span class="line">        <span class="comment">// 创建 Area 对象  </span></span><br><span class="line">        <span class="type">Area</span> <span class="variable">area</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Area</span>(Integer.valueOf(row.get(<span class="number">0</span>)), row.get(<span class="number">1</span>), Integer.valueOf(row.get(<span class="number">2</span>)),  </span><br><span class="line">                <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());  </span><br><span class="line">        <span class="comment">// 添加到 areas 中  </span></span><br><span class="line">        areas.put(area.getId(), area);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构建父子关系：因为 Area 中没有 parentId 字段，所以需要重复读取  </span></span><br><span class="line">    <span class="keyword">for</span> (CsvRow row : rows) &#123;  </span><br><span class="line">        <span class="type">Area</span> <span class="variable">area</span> <span class="operator">=</span> areas.get(Integer.valueOf(row.get(<span class="number">0</span>))); <span class="comment">// 自己  </span></span><br><span class="line">        <span class="type">Area</span> <span class="variable">parent</span> <span class="operator">=</span> areas.get(Integer.valueOf(row.get(<span class="number">3</span>))); <span class="comment">// 父  </span></span><br><span class="line">        Assert.isTrue(area != parent, <span class="string">&quot;&#123;&#125;:父子节点相同&quot;</span>, area.getName());  </span><br><span class="line">        area.setParent(parent);  </span><br><span class="line">        parent.getChildren().add(area);  </span><br><span class="line">    &#125;  </span><br><span class="line">    log.info(<span class="string">&quot;启动加载 AreaUtils 成功，耗时 (&#123;&#125;) 毫秒&quot;</span>, System.currentTimeMillis() - now);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="三、成果与收获"><a href="#三、成果与收获" class="headerlink" title="三、成果与收获"></a>三、成果与收获</h2><ol><li>掌握Git团队协作流程</li><li>熟悉真实项目开发规范</li><li>完成有偿使用库、建设项目库、确权信息库、拟建项目库等模块的开发，共计153次提交，44次合并请求</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次项目让我深刻认识到，真实项目开发不仅需要技术实现能力，更要建立工程规范意识。<br><strong>特别感谢实验室各位学长的耐心指导，也特别感谢实验室给予的条件</strong>，让我接触到真实的项目开发过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互斥锁与synchronized关键字</title>
      <link href="/2025/02/01/%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutual%20Exclusion%EF%BC%89%E4%B8%8EJava%E4%B8%AD%E7%9A%84%60synchronized%60%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2025/02/01/%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutual%20Exclusion%EF%BC%89%E4%B8%8EJava%E4%B8%AD%E7%9A%84%60synchronized%60%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>多线程环境下，确保数据一致性是一个至关重要的问题。其中一个常见的挑战是防止多个线程同时对共享资源进行修改，这可能导致数据竞争、不一致或崩溃。为了应对这一问题，Java提供了几种机制来实现互斥锁（Mutual Exclusion），其中最常用的之一就是<code>java.util.concurrent.atomic.Atomic locks</code>和<code>synchronized</code>关键字。</p><h3 id="什么是互斥锁？"><a href="#什么是互斥锁？" class="headerlink" title="什么是互斥锁？"></a>什么是互斥锁？</h3><p>互斥锁的英文是 <strong>mutual exclusion</strong>，字面意思是“相互排除”，其核心思想就是在共享资源被修改时，禁止其他线程继续操作。这种机制可以确保只有单个线程在执行某个操作期间才能获得锁，其他线程必须等待直到当前线程释放锁。</p><p>互斥锁广泛应用于以下场景：</p><ul><li>用户注册系统：防止多个用户同时尝试注册相同用户名</li><li>文件操作：防止多个程序对同一文件进行修改</li><li>数据库操作：确保数据完整性</li></ul><h3 id="Java中的synchronized关键字"><a href="#Java中的synchronized关键字" class="headerlink" title="Java中的synchronized关键字"></a>Java中的<code>synchronized</code>关键字</h3><p>Java语言中，<code>synchronized</code>是一个关键字，它用于实现互斥锁。当一个方法被标记为<code>synchronized</code>时，Java会自动在该方法开始<br>和结束的地方创建并管理一个互斥锁。这样，任何尝试同时调用这个方法的线程都会被阻止，直到当前线程完成该方法的所有操作。</p><h4 id="synchronized关键字的工作原理"><a href="#synchronized关键字的工作原理" class="headerlink" title="synchronized关键字的工作原理"></a><code>synchronized</code>关键字的工作原理</h4><ol><li><strong>锁获取</strong>：当第一个线程调用带有<code>synchronized</code>关键字的方法时，Java会自动获取锁。</li><li><strong>执行方法</strong>：允许该线程执行所有被锁保护的语句。</li><li><strong>锁释放</strong>：一旦该方法完成执行，当前线程会自动释放锁。</li><li><strong>等待释放</strong>：其他试图调用同一个方法但未被锁保护的线程会被阻塞，直到当前线程释放锁。</li></ol><h4 id="使用-synchronized的一个示例"><a href="#使用-synchronized的一个示例" class="headerlink" title="使用 synchronized的一个示例"></a>使用<code> synchronized</code>的一个示例</h4><p>以下是一个简单的用户注册系统的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (userAccount.intern()) &#123;</span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li>使用<code>synchronized</code>关键字，确保只有单个线程可以修改数据库中的用户信息。</li><li>字符串池：userAccount.intern() 返回字符串池中与 userAccount 内容相同的字符串实例。如果字符串池中不存在该字符串，则将其添加到池中并返回其引用。</li><li>同步锁：synchronized 关键字用于确保同一时间只有一个线程可以执行被同步的代码块。当多个线程尝试注册同一个用户账户时，它们都会尝试获取同一个锁对象（即 userAccount.intern() 返回的对象），从而保证这些线程不会同时进入同步代码块。</li></ul><h3 id="编写一个正确的synchronized示例"><a href="#编写一个正确的synchronized示例" class="headerlink" title="编写一个正确的synchronized示例"></a>编写一个正确的<code>synchronized</code>示例</h3><p>编写一个更复杂的例子，比如并发登录检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent locksnonatomicLocks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentLoginCheck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">loginCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLogin</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> checkLogin Method &#123;</span><br><span class="line">            <span class="keyword">if</span> (loginCount.get() &gt;= <span class="number">3</span>) &#123; <span class="comment">// 用户登录次数超过限制</span></span><br><span class="line">                System.out.println(<span class="string">&quot;账户已被冻结，建议联系管理员！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            loginCount.set(loginCount.get() + <span class="number">1</span>); <span class="comment">// 增加登录次数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户：&quot;</span> + username + <span class="string">&quot;的登录次数增加到：&quot;</span> + loginCount.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> checkLogin Method &#123;</span><br><span class="line">            <span class="keyword">if</span> (loginCount.get() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 用户已被冻结，不能再登录</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            loginCount.set(loginCount.get() - <span class="number">1</span>); <span class="comment">// 减去登录次数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户：&quot;</span> + username + <span class="string">&quot;已退出登录！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>checkLogin</code>和<code>logout</code>方法都使用了<code>synchronized</code>关键字来保护对<code>loginCount</code>计数器的访问。</li><li>这样可以防止多个线程同时修改同一个计数器，确保数据的一致性。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>锁获取的时间</strong>：在频繁竞争的情况下，过度使用互斥锁可能会导致性能问题。因此，在决定是否需要使用互斥锁时，应该权衡性能和功能需求。</li><li><strong>条件等待</strong>：当没有其他线程需要互斥锁时，可以考虑使用更轻量的条件变量（如<code>Concurrent Boolean Locks</code>）来代替互斥锁。这可以提高系统的性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理：java动态代理和静态代理</title>
      <link href="/2024/11/14/%E4%BB%A3%E7%90%86%EF%BC%9Ajava%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2024/11/14/%E4%BB%A3%E7%90%86%EF%BC%9Ajava%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="动态代理：类加载器，上下文加载器，"><a href="#动态代理：类加载器，上下文加载器，" class="headerlink" title="动态代理：类加载器，上下文加载器，"></a>动态代理：类加载器，上下文加载器，</h1><p>代理模式，是一种结构性设计模式，通过创建一个代理对象来控制对原有对象的访问。一般的，代理模式中有两个角色，代理角色和真实角色。代理类负责代理真实类，为真实类提供访问控制的功能，真实类其实是完成具体的业务逻辑。</p><p>所以，代理的主要目的就是</p><ul><li>保护目标对象</li><li>增强目标对象</li></ul><p>实现代理一般有两种实现方式:静态代理 和动态代理。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>在编译时，代理类已经被确定，需要事先手写一个代理类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建接口规范真实类的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadVideo</span><span class="params">(String filename)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建真实类实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VPlayer</span> <span class="keyword">implements</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadVideo</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载MP4视频文件：&quot;</span>+filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建静态代理类，将真实类加载到代理类内部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VPlayerProxy</span> <span class="keyword">implements</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Player player;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VPlayerProxy</span><span class="params">(Player player)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.player = player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadVideo</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        player.loadVideo(filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//直连方式</span></span><br><span class="line">        Player vplay=<span class="keyword">new</span> <span class="title class_">VPlayer</span>();</span><br><span class="line">        proxy.loadVideo(<span class="string">&quot;aaa.mp4&quot;</span>)</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理方式</span></span><br><span class="line">        Player proxy=<span class="keyword">new</span> <span class="title class_">VPlayerProxy</span>(vplay);</span><br><span class="line">        proxy.loadVideo(<span class="string">&quot;aaa.mp4&quot;</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在运行时动态的根据需求生成代理类。其中代理类有两种实现方式：</p><ul><li>java自带 java.lang.reflect.Proxy 类  （本文将重点介绍这种方法）</li><li>开源的高性能代码生成包 CGlib</li></ul><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><ol><li>创建实现InvocationHandler接口的代理工厂：在调用Proxy类的静态方法newProxyInstance时，会动态的生成一个代理类。该代理类实现了目标接口，并且持有一个InvocationHandler类型的引用</li><li>InvocationHandler接口：InvocationHandler是一个接口 他只有一个方法 invoke。在代理对象的方法被调用时，JVM会自动调用代理类的invoke方法</li><li>调用代理对象的方法：当代理对象的方法被调用时，JVM会自动调用代理类的invoke方法。可以添加调用代理类的invoke方法，并将被调用的方法名 参数等信息传递给该方法。</li><li>invoke方法调用：在invoke方法中，通过反射机制调用目标对象的方法，并返回方法的返回值，在调用目标对象的方法前后，可以执行额外的逻辑。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"><span class="comment">//定义构造器方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKProxyFactory</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                Thread.currentThread().getContextClassLoader(),<span class="comment">//当前线程的上下文ClassLoader</span></span><br><span class="line">                object.getClass().getInterfaces(), <span class="comment">//代理需要实现的接口</span></span><br><span class="line">                <span class="built_in">this</span>); <span class="comment">// 处理器自身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//进行方法匹配，调用对应方法名的方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;loadVideo&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            result=method.invoke(object, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;playVideo&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">            result=method.invoke(object, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Player player=<span class="keyword">new</span> <span class="title class_">VPlayer</span>();</span><br><span class="line">        Player proxy=<span class="keyword">new</span> <span class="title class_">JDKProxyFactory</span>(player).getProxy();</span><br><span class="line">        proxy.loadVideo(<span class="string">&quot;aaa.mp4&quot;</span>);</span><br><span class="line">        proxy.playVideo(<span class="string">&quot;aaa.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*      或者</span></span><br><span class="line"><span class="comment">        Player p=new VPlayer();</span></span><br><span class="line"><span class="comment">        Player o = (Player) Proxy.newProxyInstance(</span></span><br><span class="line"><span class="comment">                p.getClass().getClassLoader(),</span></span><br><span class="line"><span class="comment">                p.getClass().getInterfaces(),</span></span><br><span class="line"><span class="comment">                new VPlayerProxyFactory(p)</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">        o.loadVideo(&quot;aaaa.mp4&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>代理的优点</p><ul><li>隐藏了原始对象的实现细节，使得客户端不需要了解原始对象的实现</li><li>可以原始对象的基础上添加额外的功能，例如，缓存，安全验证，日志</li><li>控制对原始对象的访问，保护原始对象不会被非法访问</li></ul><p>缺点：</p><ul><li>增加了代理层，请求处理速度变慢</li><li>引入代理类增加了系统复杂程度，增加了学习成本</li></ul><p>适应场景</p><ul><li>当创建和初始化一个对象的开销很大的时候，可以使用代理模式延迟对象的实例化</li><li>日志记录，代理模式在真实的对象方法执行前后进行日志记录，实现日志记录调优</li><li>缓存代理，当客户端请求某个对象时，代理对象先检查缓存中是否存在该对象，如果存在则直接返回 否则创建新的对象并缓存起来，提高系统性能</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂设计模式和单例设计模式</title>
      <link href="/2024/11/13/%E5%B7%A5%E5%8E%82%E4%B8%8E%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/11/13/%E5%B7%A5%E5%8E%82%E4%B8%8E%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><blockquote><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p></blockquote><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>又称 静态工厂模式</p><ul><li>创建一个接口</li><li>多个实现类实现这个接口</li><li>创建简单工厂</li><li>client通过调用静态方法根据内置的匹配机制返回接口的实现类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lamborghini</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;兰博基尼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Porsche</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保时捷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(String car)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;保时捷&quot;</span>.equals(car))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Porsche</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;兰博基尼&quot;</span>.equals(car))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Lamborghini</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接调用工厂类创建产品的方法，不需要知道具体的细节，只需要知道产品名就行</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;兰博基尼&quot;</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> CarFactory.getCar(<span class="string">&quot;保时捷&quot;</span>);</span><br><span class="line"></span><br><span class="line">        car.name();<span class="comment">//兰博基尼</span></span><br><span class="line">        car1.name();<span class="comment">//保时捷</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul><li>创建一个接口</li><li>多个实现类实现接口</li><li>创建工厂接口</li><li>多个工厂实现类实现工厂接口</li><li>调用方法<code>  Car car = new LamborghiniFactory().getCar();</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lamborghini</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;兰博基尼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Porsche</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保时捷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    Car <span class="title function_">getCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LamborghiniFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Lamborghini</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PorscheFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Porsche</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用具体工厂，由具体工厂实现</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LamborghiniFactory</span>().getCar();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PorscheFactory</span>().getCar();</span><br><span class="line"></span><br><span class="line">        car.name();<span class="comment">//兰博基尼</span></span><br><span class="line">        car1.name();<span class="comment">//保时捷</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h3><p>抽象工厂模式同工厂方法模式相同，由抽象工厂，具体工厂，抽象产品和具体产品四个要素组成，但是该模式下的抽象产品数量为多个</p><ul><li>创建多个抽象产品接口</li><li>创建抽象工厂，提供了创建产品的接口</li><li>略</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><blockquote><p>该模式下只能有一个实例，必须通过自己创建自己的唯一实例，单例类必须给其他对象提供这一实例</p></blockquote><h3 id="懒单汉设计模式"><a href="#懒单汉设计模式" class="headerlink" title="懒单汉设计模式"></a>懒单汉设计模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="literal">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例类.在类初始化时，已经自行实例化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie session token JWT 略解</title>
      <link href="/2024/11/12/Cookie%E3%80%81Session%E3%80%81Toke%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2024/11/12/Cookie%E3%80%81Session%E3%80%81Toke%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie-session-token-JWT-略解"><a href="#cookie-session-token-JWT-略解" class="headerlink" title="cookie session token JWT 略解"></a>cookie session token JWT 略解</h1><p>首先要搞清以下三种</p><ul><li>认证<ul><li>验证当前用户的身份</li></ul></li><li>授权<ul><li>授权第三方应用访问该用户的某些资源</li><li>实现授权的方式有 cookie session token OAuth</li></ul></li><li>凭证<ul><li>实现认证和授权的前提</li></ul></li></ul><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><ul><li>http无状态的协议（对应事务处理没有任何记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）所以说,服务器无法分辨上一次的请求发送者和这一次的请求发送者是不是同一个人</li><li>cookie存储在客户端 他会在浏览器下次向同意服务器再次发起请求时携带并发送到服务器上</li><li>不可跨域 每个cookie都会绑定一个域名 无法在别的域名下使用 一二级域名之间可以使用</li><li>cookie中包含了许多属性<ul><li>name&#x3D;value 键值对</li><li>domain 域名</li><li>path 制定cookie在哪个路径</li><li>等等</li></ul></li></ul><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><ul><li><p>储存在服务端</p></li><li><p>记录服务器和客户端会话状态的机制</p></li><li><p>基于cookie实现</p></li><li><p>浏览器第一次向服务器发送请求时，服务器会创建一个session并返回一个sessionid 第二次请求时 需要携带cookie中的sessionid 服务器会根据seesionid判断对应&#x3D;哪个用户</p></li></ul><h2 id="什么是token"><a href="#什么是token" class="headerlink" title="什么是token"></a>什么是token</h2><ul><li>浏览器携带密码和账号请求服务器 服务器会将登录的凭证做一系列的加密后得到一串字符串作为token</li><li>服务器返回token 浏览器会将token存储起来 </li><li>每次访问api都会带着token 服务器做解密和签名认证 判断有效性</li><li>注意 token放到请求头中去</li><li>基于token校验属于一种无状态的方式 服务器不会存放token数据 用解析token的时间换取session的存储空间 减轻服务器压力 减少频繁查询数据库</li></ul><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>JSON Web Token 目前最流行的跨域认证解决方案</p><ul><li><p>类似Token 浏览器首先输入账户密码请求服务端 </p></li><li><p>服务端使用秘钥创建JWT 但是在JWT中，存储了一些会话信息 例如用户的信息，所以减少了查询数据库</p></li><li><p>颁发一个有效期极短的JWT 及时暴露了危险也很小 由于每次都会生成一个新的JWT 所以也没必要保存JWT 真正实现无状态</p></li></ul><h3 id="JWT问题"><a href="#JWT问题" class="headerlink" title="JWT问题"></a>JWT问题</h3><ul><li>因为JWT的最大优势就是不需要存储session，但是最大缺点也是因为不需要存储session导致在使用过程中无法废弃某个Token或者更改Token权限</li><li>因为本身包含了认证信息 一旦泄露 人和人都有可能获得该令牌的所有权限 为了减少盗用 jwt的有效期应该设置比较短 对于重要的权限应该再次认证</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA SPI机制</title>
      <link href="/2024/11/11/Spi%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/11/11/Spi%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="理解Java中的SPI机制"><a href="#理解Java中的SPI机制" class="headerlink" title="理解Java中的SPI机制"></a>理解Java中的SPI机制</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>spi，是jdk内置的一种服务提供发现机制，可以用来扩展或者替换组件。比如java.sql.Driver接口，其他不同的厂商可以对同一接口进行不同的实现。</p><p>SPI与API区别：</p><ul><li>API是调用并用于实现目标的类接口方法等的描述</li><li>SPI是扩展和实现以实现目标类接口方法等的描述</li></ul><p>一般来说，当服务厂商提供了一中接口的实现之后，需要在classpath下的META-INF&#x2F;services目录中创建一个以 服务接口 命名的文件 这个文件中的内容就是这个接口的具体实现类 。当其他的类调用调用到这个服务的时候，就可以查找这个jar包下的META-INF&#x2F;services&#x2F;接口名 文件的中的具体实现类的类名 可以根据这个类名进行加载实例化 就可以调用到该服务。在jdk中查找该服务的工具类是java.util.ServiceLoader</p><h2 id="如何设计一个属于自己的SPI"><a href="#如何设计一个属于自己的SPI" class="headerlink" title="如何设计一个属于自己的SPI"></a>如何设计一个属于自己的SPI</h2><p>系统实现SPI虽然简单,但是如果我们想要定制多个不同的接口实现类，就没办法在框架中，指定使用哪一个了。所以可以自己定义SPI机制的实现。</p><ol><li>定义一个接口</li><li>完成该接口的多个实现</li><li>在META-INF&#x2F;services&#x2F;目录中 以该接口的名称命名一个文件 在文件中添加该接口的实现类类名</li><li>使用ServiceLoader来加载配置文件中指定的实现<ol><li><code>ServicesLoader&lt;接口名&gt; loader=ServiceLoader.load(接口名.class)</code></li><li>使用增强for循环遍历 loader</li></ol></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在自己实现PRC框架中 <a href="https://github.com/ActingGH/Act-RPC">Act-APC</a>  使用了自定义SPI 机制 支持用户自定义序列化器并且制定键名。在该项目中内置了三个序列化器：json，kryo，hessian。使用了SPI机制后，用户可以在META-INF&#x2F;services&#x2F;serializer中自住选择想调用的序列化器</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验室新生娱乐赛题解</title>
      <link href="/2024/11/04/%E6%96%B0%E7%94%9F%E5%A8%B1%E4%B9%90%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/11/04/%E6%96%B0%E7%94%9F%E5%A8%B1%E4%B9%90%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="新生娱乐赛题解"><a href="#新生娱乐赛题解" class="headerlink" title="新生娱乐赛题解"></a>新生娱乐赛题解</h1><blockquote><p>兹所呈现之本题解，仅为个人针对此题所持观点，其既非官方所颁布之标准答案，亦未必为最优之解法。若阁下持有更佳之思路，诚邀参与讨论。</p><p>需特此说明者，本题所标注之难度，乃基于本套试题所设定之相对难度，并非该题实际固有之难度层级。</p><p>再者，虑及多数人惯常使用之编程语言状况，本套题解特选用 C 语言予以编写。兹C水平如狗啃屎，若题解之中存在讹误之处，敬祈不吝指正。</p></blockquote><p>废话不多说，开始看题：</p><h2 id="Medium-7-5-字母直方图"><a href="#Medium-7-5-字母直方图" class="headerlink" title="Medium 7-5 字母直方图"></a>Medium 7-5 字母直方图</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>读入一个字符串，对其中的字母按照不区分大小写的出现次数输出一个星号组成的直方图。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>一行，一个不超过100字节的字符串，可能含有空格。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>若干行，每行一个大写字母，空格后接着一排星号（<code>*</code>字符），星号数量与该字母的出现次数相同。为了保证图形的美观，只需要输出至少出现了2次的字母。<strong>如果字符串包含多个字母，那么按照字母首次出现的顺序输出。</strong></p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h4><p>在这里给出一组输入。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Anika, buy a banana.</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h4><p>在这里给出相应的输出。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A ******</span><br><span class="line">N ***</span><br><span class="line">B **</span><br></pre></td></tr></table></figure><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>常规思路：遍历一遍字符串，使用有顺序的Map将出现的字符和出现的次数统计，然后顺序遍历Map，如果Map的key是字母并且value的数值大于等于2 输出。</p><p>当然，大多数同学使用C语言，LinkedHashMap 并不包含于C语言，所以我们需要换一种思路：使用二维数组存储字符的ASCII码和出现的频率。（感兴趣的同学可以提前了解）</p><ul><li>遍历字符串，使用二维数组存储对应的字符的ASCII码和出现的次数。在遍历的同时需要判断该字符的大小写，可以规定为存储大写字母的ASCII码。</li><li>随后开始遍历数组，当某个字符的出现频率符合要求，输出。</li><li>输出：先将二维数组存储的ASCII码转化为大写字母 然后使用循环输出 <code>*</code> 随后换行。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span>  <span class="comment">// 包含toupper函数的头文件  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_INPUT_LEN 1000  <span class="comment">// 定义输入字符串的最大长度  </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> arr[MAX_INPUT_LEN];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>,&amp;arr);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(arr);  <span class="comment">// 计算字符串长度  </span></span><br><span class="line">        <span class="type">int</span> temp[n][<span class="number">2</span>];       <span class="comment">// 创建一个二维数组来存储字符和计数  </span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串，统计字符出现次数  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> x = arr[i];</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;  <span class="comment">// 忽略空格  </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找字符是否已经在 temp 数组中（这里为了简化，没有实现查找优化）  </span></span><br><span class="line">            <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; idx; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[j][<span class="number">0</span>] == x) &#123;</span><br><span class="line">                    temp[j][<span class="number">1</span>]++;  <span class="comment">// 如果字符已经在 temp 数组中，则增加计数  </span></span><br><span class="line">                    found = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果字符不在 temp 数组中，则添加它  </span></span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                temp[idx][<span class="number">0</span>] = x;</span><br><span class="line">                <span class="comment">// 如果字符是小写字母，则转换为大写字母  </span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">islower</span>(x)) &#123;</span><br><span class="line">                    temp[idx][<span class="number">0</span>] = (<span class="type">int</span>)<span class="built_in">toupper</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">                temp[idx][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印出现次数大于或等于 2 的字符及其星号表示  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i][<span class="number">1</span>] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c: &quot;</span>, temp[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; temp[i][<span class="number">1</span>]; j++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Medium-7-7-一元多项式的乘法与加法运算"><a href="#Medium-7-7-一元多项式的乘法与加法运算" class="headerlink" title="Medium 7-7 一元多项式的乘法与加法运算"></a>Medium <strong>7-7 一元多项式的乘法与加法运算</strong></h2><h3 id="原题："><a href="#原题：" class="headerlink" title="原题："></a>原题：</h3><p>设计函数分别求两个一元多项式的乘积与和。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>模拟。大部分同学可能没有理解</p><p>第一个多项式：</p><p>$$3x^{4}+(-5)x^{2}+6x^{11}+(-2)x^{0}$$</p><p>第二个多项式</p><p>$$5x^{20}+(-7)x^{4}+3x^{1}$$</p><p>根据本题的样例参考此公式。</p><p>得到的这两个多项式，先进行相乘，降序输出幂最高的系数和指数，例如 以上两个多项式相乘的最高次幂的项分别相乘 <code>3x^4 * 5x^20</code> 结果中系数是15 幂指数是 24 所以第一行前两个输出的是 <code>15 25</code> </p><p>思路一：定义两个二维数组，分别存储两个多项式的指数和系数 ，乘法： 使用嵌套循环 系数相乘 指数相加 ；加法： 使用查找相同的指数，指数相同系数相加 。来不及了上思路二。</p><p>思路二：定义一个结构体 ，存储每一项的系数和指数，使用结构体存储；同样的乘法是互相乘，所以使用嵌套循环，加法是只有相同次幂的项才可以过。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> coef; <span class="comment">//系数</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;  <span class="comment">//指数</span></span><br><span class="line">&#125; Term;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取第一个多项式</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n1);</span><br><span class="line">    Term *poly1 = (Term *)<span class="built_in">malloc</span>(n1 * <span class="keyword">sizeof</span>(Term)); <span class="comment">//开辟一个数组空间 数组的每个节点存储的是一个结构体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;poly1[i].coef, &amp;poly1[i].<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取第二个多项式</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n2);</span><br><span class="line">    Term *poly2 = (Term *)<span class="built_in">malloc</span>(n2 * <span class="keyword">sizeof</span>(Term));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;poly2[i].coef, &amp;poly2[i].<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算乘积</span></span><br><span class="line">    <span class="type">int</span> maxExpMul = poly1[<span class="number">0</span>].<span class="built_in">exp</span> + poly2[<span class="number">0</span>].<span class="built_in">exp</span>;</span><br><span class="line">    Term *mulResult = (Term *)<span class="built_in">calloc</span>(maxExpMul + <span class="number">1</span>, <span class="keyword">sizeof</span>(Term)); <span class="comment">//开辟数组空间存储结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">            <span class="type">int</span> newExp = poly1[i].<span class="built_in">exp</span> + poly2[j].<span class="built_in">exp</span>;</span><br><span class="line">            <span class="type">int</span> newCoef = poly1[i].coef * poly2[j].coef;</span><br><span class="line">            mulResult[newExp].coef += newCoef; <span class="comment">//将新系数加到mulResult中相应指数的位置上。</span></span><br><span class="line">            mulResult[newExp].<span class="built_in">exp</span> = newExp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算和</span></span><br><span class="line">    <span class="type">int</span> maxExpAdd = poly1[<span class="number">0</span>].<span class="built_in">exp</span> &gt; poly2[<span class="number">0</span>].<span class="built_in">exp</span> ? poly1[<span class="number">0</span>].<span class="built_in">exp</span> : poly2[<span class="number">0</span>].<span class="built_in">exp</span>;</span><br><span class="line">    Term *sumResult = (Term *)<span class="built_in">calloc</span>(maxExpAdd + <span class="number">1</span>, <span class="keyword">sizeof</span>(Term)); <span class="comment">//开辟数组空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        sumResult[poly1[i].<span class="built_in">exp</span>].coef += poly1[i].coef;</span><br><span class="line">        sumResult[poly1[i].<span class="built_in">exp</span>].<span class="built_in">exp</span> = poly1[i].<span class="built_in">exp</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">        sumResult[poly2[i].<span class="built_in">exp</span>].coef += poly2[i].coef;</span><br><span class="line">        sumResult[poly2[i].<span class="built_in">exp</span>].<span class="built_in">exp</span> = poly2[i].<span class="built_in">exp</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出乘积</span></span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = maxExpMul; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="keyword">if</span> (mulResult[i].coef != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, mulResult[i].coef, mulResult[i].<span class="built_in">exp</span>);</span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出和</span></span><br><span class="line">    first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = maxExpAdd; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumResult[i].coef != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, sumResult[i].coef, sumResult[i].<span class="built_in">exp</span>);</span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(poly1);</span><br><span class="line">    <span class="built_in">free</span>(poly2);</span><br><span class="line">    <span class="built_in">free</span>(mulResult);</span><br><span class="line">    <span class="built_in">free</span>(sumResult);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hard-7-8-二分查找"><a href="#Hard-7-8-二分查找" class="headerlink" title="Hard 7-8 二分查找"></a>Hard 7-8 二分查找</h2><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><p>利用二分查找找出所给出的数在数组中的下标</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h4><p>第一行输入n和m表示数组有n个数据，m表示要对m个数进行查找</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h4><p>所有输出在一行完成，行末没有多余空格和多余回车。</p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例:"></a>输入样例:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例:"></a>输出样例:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h3><p>二分，经典算法。“二分查找只能用于有序数列，即有单调性的序列。二分查找的主要原理就是，不断通过取中间值，缩小范围，直到找到。其时间复杂度为O（logn）。” 题目没有直接说明给出的数组是有序的，是一个隐含条件；</p><p>既然是有序的数列，就不需要每次查找都从头开始遍历，只需要比对中间的值。以本题为例，给出一个<strong>升序</strong>的数组，查找x在数组中的位置，只需要每次用x比对一下中间的数，如果中间的数小于要找的x，那么x一定在中间的数的右边。反之，在左边。</p><p>大部分同学没通过的原因是时间超出范围。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//切记二分查找只能用于有序数列。</span></span><br><span class="line"><span class="comment">//二分查找的主要原理就是，不断通过取中间，缩小范围，直到找到。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> arr[n];<span class="comment">//在这里设置数组，避免不必要的错误。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;value);</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;value)&#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;<span class="comment">//三个判断是核心。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&lt;value)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]==value)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==m<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,mid);<span class="comment">//题目要求的是打印下标</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//格式打印</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,mid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//找到直接跳出，否则无限循环，出现错误。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发</title>
      <link href="/2024/09/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/"/>
      <url>/2024/09/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>前端：html、css、js、组件库</p><p>部署：linux操作系统、docker（可选）、后端语言</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>主流的部署工具 可以参考主页的docker文章学习</p><p>部署高效便捷</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>微信开发者工具 或者 hbuilder（一次编写多个小程序 微信小程序，支付宝小程序、百度小程序等等）</p><p>微信开发者工具需要使用微信前端语法 学习成本较低 可以更好配置组件库进行使用</p><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><p>根据微信官方的要求 从小程序发出的 <strong>请求需要进行合法校验</strong> 包括以下几个步骤</p><ul><li><p>服务器 </p><ul><li>购买服务器后 使用本地连接工具连接远程服务器</li><li>Xshell、finalShell</li><li>服务器商家<ul><li>腾讯云 三个月免费使用</li><li>阿里云 一个月免费使用</li><li>阿里云 学生认证新用户 99 一年</li></ul></li></ul></li><li><p>域名 </p><ul><li>购买域名 可以与不同于服务器厂家 哪家便宜买哪个</li><li>解析到自己的服务器</li><li>推荐华为云 优惠力度大</li></ul></li><li><p>备案</p><ul><li>将域名备案到自己的服务器</li><li>时间周期 20天左右</li></ul></li><li><p>ssl证书 （http-&gt;https）</p><ul><li>阿里云用户测试证书 前三个月免费</li><li>java后端可以将证书直接安装带程序中 配置简单</li><li>nginx配置 （web服务器） 将请求转发到对应的接口</li></ul></li></ul><p><strong>注意：以上部署准备属于常规部署 更加便捷方便可以选择微信官方的云部署（小的没有使用过 费用是弹性资源使用量计费） 不需要考虑以上所有</strong></p><h2 id="上线准备"><a href="#上线准备" class="headerlink" title="上线准备"></a>上线准备</h2><ul><li>小程序 审核 1天<ul><li>需要保证请求已经合法化 没有bug 减少审核次数</li></ul></li><li>小程序微信认证 <ul><li>费用30  用户可以通过搜索名称直接搜到小程序</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="/2023/12/30/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/30/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><p>初始Docker</p><p>开源应用容器引擎 </p><p>启动 systemctl start docker</p><p>查看状态 systemctl status docker</p><h4 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h4><ul><li>查看镜像<ul><li>docker images[-q 查看镜像ID]</li></ul></li><li>搜索镜像<ul><li>docker search</li></ul></li><li>下载镜像<ul><li>docker pull</li></ul></li><li>删除<ul><li>docker rmi</li></ul></li></ul><h4 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h4><ul><li>查看容器<ul><li>docker ps  仅仅查看运行中的容器</li><li>-a 查看所有历史</li></ul></li><li>创建容器<ul><li>docker run </li><li>-i  保持运行</li><li>-t 分配终端</li><li>-d 后台运行 需要执行进入命令 退出后不会关闭</li><li>–name&#x3D; 起名字</li></ul></li><li>进入容器<ul><li>docker exec  -it可以进行交互 bash交互</li></ul></li><li>停止容器<ul><li>docker stop</li></ul></li><li>启动容器<ul><li>docker start</li></ul></li><li>删除容器<ul><li>docker rm</li></ul></li><li>查看容器信息<ul><li>docker inspect</li></ul></li></ul><h4 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h4><p>容器内部只模拟该程序运行所必要的系统 所以vim编辑器并不存在 所以无法直接修改容器内部的文件需要使用数据卷挂载间接修改文件内容</p><p><strong>如果容器已经创建 无法挂载数据卷</strong></p><p><strong>如果数据卷不存在则自动创建该数据卷</strong></p><p>数据卷是宿主机的一个目录或文件</p><ul><li>容器数据持久化</li><li>外部机器和容器的间接通信</li><li>容器间数据交换</li></ul><p>配置数据卷</p><ul><li>Docker run …. -v 宿主机目录:容器内目录</li><li>注意<ul><li>目录必须是绝对路径</li><li>目录不存在会自动创建</li><li>可以挂载多个数据卷</li></ul></li></ul><p>多容器进行数据交换</p><ol><li>多容器挂载同一个数据卷</li><li>数据卷容器</li></ol><p>配置数据卷容器</p><ol><li>创建c3数据卷容器 使用-v参数 设置数据卷<ul><li>docker run -it –name&#x3D;c3 -v &#x2F;volume centos:7</li></ul></li><li>创建启动c1 c2容器 使用–volumes-from参数 设置数据卷<ul><li>docker run -it –name&#x3D;c1 –volumes-from c3 centos:7</li><li>docker run -it –name&#x3D;c2 –volumes-from c3 centos:7</li></ul></li></ol><h4 id="Docker应用部署"><a href="#Docker应用部署" class="headerlink" title="Docker应用部署"></a>Docker应用部署</h4><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><ol><li>搜索MySQL镜像</li><li>拉取镜像</li><li>创建容器</li><li>操作容器中的MySQL</li></ol><p><img src="/images/typora-user-images/image-20240131134116891.png" alt="image-20240131134116891"></p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>不同linux发行版 bootfs基本相同  rootfs不同</p><p>docker镜像是由特殊文件系统叠加而成</p><p><img src="/images/typora-user-images/image-20240131154252124.png" alt="image-20240131154252124"></p><h5 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h5><ul><li>容器转镜像<ul><li>docker  commit 容器ID 镜像名称：版本号<ul><li>目录挂载无法被commit</li></ul></li><li>镜像转压缩文件<ul><li>docker save -o 压缩文件名称 镜像名称：版本号</li></ul></li><li>压缩文件转镜像<ul><li>docker load -i 压缩文件名称</li></ul></li></ul></li><li>dockerfile<ul><li>是一个文本文件</li><li>包含一条条指令<ul><li>FROM 指定父镜像</li><li>MAINTAINER 作者信息</li><li>LABEL  标签</li><li>RUN 执行命令</li><li>CMD 容器启动命令</li></ul></li></ul></li></ul><p><img src="/images/typora-user-images/image-20240527165508879.png" alt="image-20240527165508879"></p><p>rmi 删除镜像 rm删除容器</p><p>遇到不会的指令直接 –help</p><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><ul><li>准备系统运行环境</li><li>准备jre配置环境变量</li><li>拷贝jar包</li><li>编写运行脚本</li></ul><p><strong>层</strong> 添加安装包依赖配置都形成新的每一层</p><p>使用dockerfile来描述</p><p><img src="/images/typora-user-images/image-20240527174310654.png" alt="image-20240527174310654"></p><p><img src="/images/typora-user-images/image-20240527174615644.png" alt="image-20240527174615644"></p><p>简化 直接在jdk镜像上配置<img src="/images/typora-user-images/image-20240527174722324.png" alt="image-20240527174722324"></p><p><img src="/images/typora-user-images/image-20240527180951989.png" alt="image-20240527180951989"></p><p>注意 <code>.</code> </p><p><img src="/images/typora-user-images/image-20240527181811615.png" alt="image-20240527181811615"></p><p><strong>通过自定义网络</strong>可以通过容器名直接进行网络连接 无需指定ip地址</p><h2 id="dockercompose"><a href="#dockercompose" class="headerlink" title="dockercompose"></a>dockercompose</h2><p>通过单独的模板文件来定义一组性关联的应用容器 帮助我们实现多个相关联的docker容器的快速部署</p><p><img src="/images/typora-user-images/image-20240527185523676.png" alt="image-20240527185523676"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门</title>
      <link href="/2023/12/30/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/30/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li>顶级目录 &#x2F; 有且只有一个</li><li>Windows \ 表示层级关系</li><li>Linux &#x2F; 表示层级关系</li></ul><h2 id="Linux命令入门"><a href="#Linux命令入门" class="headerlink" title="Linux命令入门"></a>Linux命令入门</h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>command [-options] [parameter]</p><ul><li>command 命令本身</li><li>-options 命令选项 行为细节</li><li>parameter 命令参数 指向目标</li></ul><h3 id="ls命令入门"><a href="#ls命令入门" class="headerlink" title="ls命令入门"></a>ls命令入门</h3><p>ls 列出目录下的内容</p><p>ls [-a -l -h] [linux路径]</p><ul><li>-a all 列出全部文件 包括隐藏（ 以. 开头是隐藏文件夹）</li><li>-l 竖向排列 并展示更多信息</li><li>ls -l -a 即 ls -la</li><li>-h 文件大小带单位</li></ul><p>cd切换工作目录（change directory）</p><p>cd [linux路径]</p><p>pwd （print work directory）</p><p>查看当前所在的工作目录</p><h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><ul><li>. 表示当前目录</li><li>.. 表示上一级目录 ..&#x2F;.. 退回两级</li><li>~ 表示home目录</li></ul><h4 id="创建目录命令"><a href="#创建目录命令" class="headerlink" title="创建目录命令"></a>创建目录命令</h4><ul><li>mkdir （make directory）</li><li>mkdir [-p] linux路径</li><li>-p 表示自动创建不存在的父目录 适用创建连续多层级的目录</li><li>确保在home目录内</li></ul><h4 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h4><ul><li><p>touch 创建文件</p><ul><li>touch Linux路径</li></ul></li><li><p>cat  查看文件内容</p><ul><li>cat Linux路径</li></ul></li><li><p>more 支持翻页查看文件内容</p><ul><li>more Linux路径</li><li>空格 翻页</li><li>q 退出</li></ul></li><li><p>cp 复制文件夹</p><ul><li>cp [-r] 参数1 参数2</li><li>-r用于复制文件夹</li><li>参数1 被复制文件</li><li>参数2 复制去的地方</li></ul></li><li><p>mv 文件移动 改名</p><ul><li>mv 参数1 参数2</li></ul></li><li><p>rm 删除文件 文件夹</p><ul><li>rm [-r -f] 参数1 参数2….</li><li>-r 删除文件夹</li><li>-f force 强制删除 不会出现确认信息</li><li>通配符<ul><li>test* 匹配以test开头的文件</li><li>*test* 匹配包含test的文件</li></ul></li></ul></li></ul><h4 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h4><ul><li>which <ul><li>which 要查找的命令</li><li>找到二进制可执行文件</li></ul></li><li>find <ul><li>find 起始路径 -name “被查找的文件名”</li><li>find 起始路径 -size +|- n [kMG]<ul><li>+表示大于 - 表示小于</li><li>n 表示大小</li><li>kMG表示单位</li></ul></li></ul></li></ul><h4 id="过滤命令"><a href="#过滤命令" class="headerlink" title="过滤命令"></a>过滤命令</h4><ul><li>grep<ul><li>grep [-n] 关键字 文件路径</li><li>-n 表示在结果中显示匹配的行的行号</li><li>关键字 表示过滤的关键字</li><li>文件路径 可作为内容输入端口</li></ul></li></ul><h4 id="数量统计"><a href="#数量统计" class="headerlink" title="数量统计"></a>数量统计</h4><ul><li>wc<ul><li>wc [-c -m -l -w] 文件路径</li><li>c 统计bytes数量</li><li>m 统计字符数量 symble</li><li>l 统计行数</li><li>w 统计单词数量</li><li>文件路径 可作为内容输入端口</li></ul></li></ul><p>管道符</p><ul><li>|<ul><li>将左边的结果 作为右边的输入</li></ul></li></ul><p>echo命令</p><ul><li>echo 输出内容</li></ul><p>反引号 &#96;</p><ul><li>执行被包围的内容</li></ul><p>重定向符</p><ul><li>&gt; 左侧内容覆盖到指定文件中</li><li>&gt;&gt;左侧内容追加到指定文件中<ul><li>自动换行</li></ul></li></ul><p>tail</p><ul><li>查看文件尾部内容</li><li>tail [-f -num] linux路径</li><li>-f 追踪</li><li>-num 查看尾部多好行</li><li>ctrl + c 退出</li></ul><p>vi&#x2F;vim 编辑器</p><ul><li>vim 文件路径</li><li>不存在即创建新文件</li><li>i 进入输入模式  esc回到命令模式</li><li>dd 删除 u撤回</li><li>：wq 保存退出</li><li><img src="/images/typora-user-images/image-20240130182550029.png" alt="image-20240130182550029"></li><li><img src="/images/typora-user-images/image-20240130182903565.png" alt="image-20240130182903565"></li><li><img src="/images/typora-user-images/image-20240130183348632.png" alt="image-20240130183348632"></li></ul><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><ul><li><p>root用户（超级管理员）</p><ul><li>su - root  （Switch USER）</li><li>退出 exit</li></ul></li><li><p>授权命令</p><ul><li>sudo 其他命令</li><li>需要为普通用户配置sudo认证<ul><li>切换root用户 </li><li>visudo</li><li>acting ALL&#x3D;（ALL） NOPASSWORD</li></ul></li></ul></li><li><p>用户，用户组</p><ul><li>groupadd 用户组名</li><li>groupdel 用户组名</li></ul></li></ul><h4 id="应用商店"><a href="#应用商店" class="headerlink" title="应用商店"></a>应用商店</h4><p>yum RPM包软件管理器</p><ul><li>yum [-y] [install   remove  search] 软件名称<ul><li>y 自动确认 无需手动确认</li></ul></li></ul><p>systemctl</p><ul><li>systemctl 指令 服务名</li><li>指令<ul><li>stop停止</li><li>start 启动</li><li>status 查看状态</li><li>enable 开启开机自启动</li><li>disable 关闭开机自启</li></ul></li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>ln -s 参数1 参数2</p><ul><li>参数1 被链接的文件</li><li>参数2 链接去的目的地</li></ul><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>date [-d] [+格式化字符串]</p><ul><li>-d 一般用于时间计算</li></ul><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>127.0.0.1 指代本机</p><p>0.0.0.0 </p><p>可以指代本机</p><p>在一些ip限制中 表示所有ip</p><p>端口绑定中确定绑定关系</p><h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><p>hostnamectl set-hostname 主机名</p><p>域名解析  dns服务器（114.114.114.114，8.8.8.8）</p><p>私人地址本</p><p>Windows   C:\Windows\System32\drivers\etc\hosts</p><p>Linux            &#x2F;etc&#x2F;hosts</p><p>DHCP 动态获取IP地址 重启设备都会重新获取</p><p>ping命令</p><p>ping [-c num] ip或主机名</p><ul><li>c 检查次数 不使用将无限次数</li></ul><p>wget [-b] url</p><ul><li>b 后台下载</li></ul><p>tomcat 启动 进入&#x2F;usr&#x2F;local&#x2F;tomcat </p><p>&#x2F;bin 使用sh  startup.sh</p><p><img src="/images/typora-user-images/image-20240506222111780.png" alt="image-20240506222111780"></p><p>ip addr 查看ens33 ip地址</p><p>链接：<a href="https://pan.baidu.com/s/1DY5WDOZTqkG5hEvsIFWgWw">https://pan.baidu.com/s/1DY5WDOZTqkG5hEvsIFWgWw</a><br>提取码：04au</p><p>启动mysql服务</p><p>systemctl start mysqld</p><p>后台运行Springboot 并将日志输出到文件</p><p><img src="/images/typora-user-images/image-20240512121557606.png" alt="image-20240512121557606"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql高级</title>
      <link href="/2023/12/30/MySql%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/12/30/MySql%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务会把所有操作作为一个整体一起向系统提交或撤销操作星球 这些操作要么同时成功要么同时失败</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>查看 设置事务</p><p><code>SELECT @@autocommit;</code></p><p><code>SET @@AUTOCOMMIT=0</code> 设置为手动提交</p><p>提交事务<code>COMMIT</code></p><p>回滚事务 <code>ROLLBACK</code></p><p>开启事务 <code>start transction</code>或 <code>begin</code></p><p>事务正常运行    提交事务 <code>commit</code></p><p>事务中途失败    回滚事务 <code>rollback</code></p><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li>原子性  事务是不可分割的最小单元 要么全部成功 要么全部失败</li><li>一致性 事务完成时  必须使所有数据都保持一致</li><li>隔离性  数据库提供隔离机制 保证事务在不收外部并发操作影响的独立环境</li><li>持久性  事务一旦提交或回滚 数据库中数据改变持久性</li></ul><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p><strong>赃读</strong> 一个事务读取到另一个事务还没有提交的数据       （隔离解决方法：A事务并不会读取到）</p><p><strong>不可重复读</strong> 一个事务先后读取同一条记录 但两次读取的数据不同   （隔离解决方法：A事务读取到的数据相同 并没有受到改变）</p><p><strong>幻读</strong> 一个事务按照条件查询数据时 没有对应的数据行 但是在插入数据时 又发现了这条数据的存在（隔离解决方法：B事务阻塞无法无法新插入要查询的数据）</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th>隔离级别</th><th>赃读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted                    读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>read committed                                读已提交（orical数据库默认）</td><td>×</td><td>√</td><td>√</td></tr><tr><td>repeatable read（mysql中默认）                     可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>serializable                                                         串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>查看事务隔离级别 <code>SELECT @@transacyion_isolation;</code></p><p>设置事务隔离级别</p><p><code>set [session | global] transaction isolation level &#123;  四种级别  &#125;;</code></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>计算机协调多个进程或线程并发访问某一种资源的机制</p><p><strong>粒度</strong></p><ul><li>全局锁 锁住数据库中所有表</li><li>表级锁 锁住整张表</li><li>行级锁 锁住对应行数</li></ul><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>锁后 只能进行读取  全库的数据备份 从而获取一致性视图</p><p>全局锁 <code>flush tables with read lock;</code></p><p>备份 <code>mysqldump -u root -p 12345 database_name &gt; xxx.sql;</code>(在windows命令行执行)</p><p>解锁 <code>unlock tables ;</code></p><p> 在innodb引擎中 备份添加参数 <code>--sing-transaction</code>完成不加锁的一致性备份</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>每次操作锁住整张表</p><ul><li>表锁</li><li>元数据锁</li><li>意向锁</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li><strong>表共享读锁</strong>  （读锁）所用客户端只能读</li><li><strong>表独占写锁</strong>  （写锁）其他客户端读写都被阻塞</li></ul><p>加锁 <code>lock tables table_name read/write</code></p><p>释放锁 <code>unlock tables</code></p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>系统自动控制加锁  维护表元数据的数据一致性 在表上有活动事务的时候 不可以对元数据进行写入操作</p><p>当对表进行增删改查的时候 自动加<strong>共享锁</strong></p><p>​增删改 自动加写锁</p><p>​查看 自动加读锁</p><p>当对表结构进行变更的时候 自动加<strong>排他写锁</strong></p><p>排他锁与其他所有锁都互斥</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>解决在执行dml语句中 加的行锁与表锁的冲突 在innodb引擎加入了意向锁 使得表锁不用检查每行数据是否加锁 使用意向锁来减少表锁的检查</p><ul><li>意向共享锁（IS）  select…lock in share mode（添加行锁共享锁同时添加意向共享锁）</li><li>意向排他锁 （IX）insert update delete select…for update</li></ul><p>兼容问题</p><p><strong>意向共享锁：</strong>与表锁共享锁（read）兼容 与表锁排他锁（write）互斥</p><p><strong>意向排他锁：</strong>与表锁共享锁（read）以及排他锁（write）都互斥 意向锁之间不会互斥</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>锁住对应数据行的数据 </p><p>行锁是通过对索引上的索引行加锁来实现的而不是对记录加的锁</p><ul><li><strong>行锁</strong> 锁定单行数据 防止其他事务对此进行update和delete</li><li><strong>间隙锁</strong> 锁定索引记录的间隙（不含该记录）确保索引记录间隙不变 防止其他事务在这个间隙进行insert 产生幻读 在RR隔离级别下都支持</li><li><strong>临建锁</strong> 行锁和间隙锁组合 同时锁住数据并锁住数据前面的间隙</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>共享锁（S）允许一个事务读取一行 阻止其他事务获得相同数据集的排他锁</li><li>排他锁（X）允许获取排他锁的事务更新数据 阻止其他事务获取相同数据集的共享锁和排他锁</li></ul><table><thead><tr><th>sql</th><th>行锁类型</th><th align="center">说明</th></tr></thead><tbody><tr><td>insert</td><td>排他锁</td><td align="center">自动</td></tr><tr><td>update</td><td>排他锁</td><td align="center">自动</td></tr><tr><td>delete</td><td>排他锁</td><td align="center">自动</td></tr><tr><td>select</td><td>不加锁</td><td align="center"></td></tr><tr><td>select..lock in share mode</td><td>共享锁</td><td align="center">手动</td></tr><tr><td>select..for update</td><td>排他锁</td><td align="center">手动</td></tr></tbody></table><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>默认情况下 innodb在repeatable read事务隔离级别运行 innodb使用next-key进行搜索和索引扫描 以防止幻读</p><ol><li>索引上的等值查询（唯一索引）给不存在的记录加锁时 优化为间隙锁</li><li>索引上的等值查询（普通索引） 向右遍历时最后一个值不满足查询需求时 临建锁退化为间隙锁</li><li>索引上的范围查询（唯一索引）会访问到不满足条件的第一个值为止</li></ol><p>间隙锁唯一目的是防止其他事务插入间隙 间隙锁可以共存 一个事务采用的间隙锁不会组织两一个事务在同一个间隙上采用间隙锁</p><h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>存储正常运行的各种信息</p><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><p>元数据体系 数据库 表 字段类型及访问权限</p><h3 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance_schema"></a>performance_schema</h3><p>为服务器运行时提供了一个底层监控的功能 主要用于收集服务器性能参数</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>包含了一系列方便dba和开发人员利用performance_schema 性能数据库进行性能调优和诊断</p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u 指定用户名</span><br><span class="line">-p 指定密码</span><br><span class="line">-h 指定服务器ip或域名</span><br><span class="line">-P 指定连接端口号</span><br><span class="line">-e 执行sql语句并退出（可以在客户端执行sql语句 而不用连接数据库）</span><br></pre></td></tr></table></figure><h2 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h2><p>执行管理操作的客户端程序 可以用它检查服务器的配置和当前状态 创建并删除数据库等</p><p>不指定主机名和端口号 默认本主机3306</p><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>服务器生成的二进制文件 需要用到mysqlbinlog管理工具</p><p><code>mysqlbinlog [options] log-files...</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d 指定数据库名称</span><br><span class="line">-o 忽略日志中前n行的命令</span><br><span class="line">-r 将输出的文本格式日志输出到指定文件</span><br><span class="line">-s 显示简单个事 省略一些信息</span><br></pre></td></tr></table></figure><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><p><strong>批量插入</strong></p><p><code>insert into table-name values(1,&#39;tom),(2,&#39;cat)...;</code></p><p><strong>手动事务提交</strong></p><p><code>start transction;</code></p><p><code>commit</code></p><p><strong>主键顺序插入</strong></p><h3 id="大批量数据插入"><a href="#大批量数据插入" class="headerlink" title="大批量数据插入"></a>大批量数据插入</h3><p>load指令</p><ol><li>客户端连接服务端时 添加参数 <code>--local-infile</code></li><li>设置全局参数 <code>set global local_infile=1</code></li><li>执行load指令 将准备好的数据加载到表结构中去 <code>load data local infile &#39;filename.log&#39; into table &#39;table_name&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;</code></li></ol><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>主键设置原则</p><ul><li>满足业务需求的情况下 尽量降低主键的长度</li><li>插入数据时 尽量选择顺序插入 使用AUTO_INCREMENT自增主键</li><li>尽量不要使用UUID做主键或者是其他自然主键 如身份证号</li><li>业务操作时避免对主键的修改</li></ul><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><ol><li>using filesort：通过表的索引或全表扫描 读取满足条件的数据行 然后再排序缓冲区sort buffer中完成排序操作 所有不是通过索引直接返回排序结果的牌徐都叫 filesort排序</li><li>using idex 通过有序索引顺序扫描直接返回有序数据 这种情况即为using index 不需要额外排序 操作效率高</li></ol><p>需要为排序的字段创建索引</p><p><code>create index index_name on table_name(字段1,字段2)</code></p><p>注意创建字段索引的顺序要与排顺时字段顺序相同 （最左前缀法则）</p><p>默认升序排序 asc 降序排序 desc</p><p>创建字段索引时可以指定升序降序</p><p>如果全部字段遵循一致的排列顺序 则不需要额外指定字段排序</p><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><p>出现 using temporary 临时表 效率极低</p><p>创建联合索引 注意最左前缀法则</p><p>where 先出现group by后出现 依旧可以满足最左前缀法则</p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>分页查询</p><p>大数据量分页 越往后 耗时越长</p><p>优化 覆盖索引 子查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>例子</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name limit <span class="number">9000000</span>,<span class="number">10</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>优化</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> table_name <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="keyword">select</span> id <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>,<span class="number">10</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者</span><br><span class="line"><span class="keyword">select</span> name1.<span class="operator">*</span> <span class="keyword">from</span> table_name1 name1,(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>,<span class="number">10</span>) name2 <span class="keyword">where</span> name1.id<span class="operator">=</span>name2.id;</span><br></pre></td></tr></table></figure><h2 id="count-优化"><a href="#count-优化" class="headerlink" title="count 优化"></a>count 优化</h2><p>myisam 引擎会把一个表的总行数存在磁盘上 执行count *效率高</p><p>innodb 执行count* 时 需要把数据一行一行地从引擎里读出来 然后累计计数</p><p>优化思路：自己计数 自己维护</p><p>count几种方式</p><ul><li><p>count 主键</p><ul><li>innodb会遍历整张表 每一行的主键提取出来 返回给服务层 服务层进行累加</li></ul></li><li><p>count 字段 </p><ul><li>没有not null 约束 遍历整张表的每一行的字段返回给服务层 判断是否为null</li><li>有约束 每一行提取出来返回给服务层 直接按行累加</li></ul></li><li><p>count * </p><ul><li>不取值直接累加</li></ul></li><li><p>count 1</p><ul><li>遍历整张表 不取值 放数字进去后直接按行进行累加</li></ul></li></ul><p>count *效率最高 count 1 count主键 count字段</p><h2 id="update-优化"><a href="#update-优化" class="headerlink" title="update 优化"></a>update 优化</h2><p>update 条件中没有使用索引的话 会锁住整张表</p><p>innodb是针对索引加的锁 不是针对记录加锁 并且索引不能失效 否则行锁升级为表锁</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git版本控制进阶</title>
      <link href="/2023/12/30/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/30/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="git基础学习"><a href="#git基础学习" class="headerlink" title="git基础学习"></a>git基础学习</h1><h2 id="Git有什么作用？"><a href="#Git有什么作用？" class="headerlink" title="Git有什么作用？"></a>Git有什么作用？</h2><blockquote><p>Git是一个免费的、开源的分布式版本控制系统，用于追踪代码的改动，记录每个文件的修改历史，包括修改内容、作者、时间等，并允许开发者在不同的开发线（分支）上进行并行开发。它最主要的优势在于，所有的这些数据都是本地存储的，使得开发者即使在没有网络连接的情况下也能进行工作</p></blockquote><h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Acting&quot; //配置用户名</span><br><span class="line"></span><br><span class="line">git config --global user.email 2864094036@qq.com //配置邮箱</span><br><span class="line"></span><br><span class="line">git config --global credential.help store //无需密码登录</span><br><span class="line"></span><br><span class="line">git config --global --list //查看配置信息</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">global 全局配置 所有仓库生效</p><p>system 系统配置 对所有用户生效</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>方式一 在本地创建仓库 git init</p><p>方式二 在远程服务器克隆一个已经存在的仓库 git clone</p><p>git add 添加到暂存区 </p><p>git commit 提交</p><p>git log查看提交信息 –oneline 简洁提交记录</p><h2 id="回退撤销操作"><a href="#回退撤销操作" class="headerlink" title="回退撤销操作"></a>回退撤销操作</h2><p>git reset –soft 保存工作区和暂存区</p><p>git reset –hard 丢弃工作区和暂存区</p><p>git reset –mixed 只保留工作区 丢弃暂存区</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>查看差异</p><p>git diff  工作区vs暂存区</p><p>git diff HEAD 工作区 vs 本地仓库</p><p>git diff -</p><p>git diff HEAD~ HEAD 比较当前版本与之前版本</p><p>git diff HEAD~n HEAD 比较当前版本与之前第n个版本</p><p>git rm 删除文件</p><p>git rm -cached 仅删除版本库中文件</p><h2 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="headerlink" title="gitignore忽略文件"></a>gitignore忽略文件</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><ol><li><strong>每一行一个规则</strong>：<code>.gitignore</code> 文件中的每一行都定义了一个匹配规则。</li><li><strong>匹配模式</strong>：可以使用通配符来匹配文件名或目录名。</li><li><strong>注释</strong>：以 <code>#</code> 开头的行是注释，会被 Git 忽略。</li></ol><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li><code>*</code>：匹配任意字符（不包括目录分隔符）。</li><li><code>?</code>：匹配任意单个字符（不包括目录分隔符）。</li><li><code>[abc]</code>：匹配方括号中列出的任意一个字符。</li><li><code>**</code>：匹配多级目录和文件。</li><li><code>&#123;&#125;</code>：可以组合多个模式，例如 <code>&#123;*.log,*.txt&#125;</code></li></ul><p>Java开发在<code>.gitignore</code>文件中一般会存放以下几类文件：</p><ol><li><strong>编译生成的文件</strong>：包括由Java编译器生成的<code>.class</code>文件，以及可能由其他工具生成的如<code>.jar</code>、<code>.o</code>、<code>.pyc</code>等文件。这些文件通常不需要提交到版本控制系统中，因为它们是由源代码编译得到的，且可能会非常大。</li><li><strong>构建产物和输出</strong>：包括由构建工具（如Maven、Gradle等）生成的目录和文件，如<code>target/</code>、<code>build/</code>、<code>dist/</code>等。这些文件通常是运行代码的结果，但在版本控制中跟踪它们并不必要。</li><li><strong>配置文件</strong>：一些集成开发环境（IDE）如Eclipse、IntelliJ IDEA、NetBeans等生成的配置文件，如<code>.project</code>、<code>.classpath</code>、<code>.idea/</code>、<code>*.iml</code>等。这些文件可能包含特定于开发环境的设置，因此不应该提交到版本控制系统中。</li><li><strong>日志文件</strong>：包括<code>*.log</code>文件和<code>logs/</code>目录等。这些文件通常包含运行时生成的日志信息，对于版本控制来说并不是必需的。</li><li><strong>临时文件</strong>：如<code>*.swp</code>、<code>*~</code>、<code>*.tmp</code>等。这些文件是编辑过程中产生的临时文件，不需要提交到版本控制系统中。</li><li><strong>用户特定文件</strong>：如<code>.metadata/</code>等。这些文件包含特定于用户的设置和元数据，不应该提交到版本控制系统中。</li><li><strong>敏感信息</strong>：如密码、API密钥、访问令牌等敏感信息。这些信息应该避免存储在版本控制系统中，以防止泄露和安全风险</li></ol><h2 id="分支操作基本命令"><a href="#分支操作基本命令" class="headerlink" title="分支操作基本命令"></a>分支操作基本命令</h2><p>git branch 查看当前所有分支 星号所在位置就是当前分支</p><p>git branch 分支名 自定义创建新的分支</p><p>git switch 分支名 切换分支</p><p>git merge 分支名 合并该分支名到当前分支</p><p>git log –graph –oneline –decorate –all 查看分支图</p><p>git branch -d 分支名   删除分支 如果该分支没有被合并 需要将小写d改为大写D</p><p>分支冲突</p><p>git diff 查看冲突内容</p><p>起别名</p><p>alias 别名&#x3D;”操作命令”</p><p>merge 不会破坏分支提交历史 方便回溯查看 会产生额外的提交节点 分支图比较复杂</p><p>rebase 形成线性历史 比较直观干净 会改变提交历史 （避免在共享分支使用）</p><h2 id="git分支管理和工作流模型"><a href="#git分支管理和工作流模型" class="headerlink" title="git分支管理和工作流模型"></a>git分支管理和工作流模型</h2><p>main  主线分支     最新稳定</p><p>hotfix 问题修复分支</p><p>develop 开发分支 </p><p>feature 功能分支</p><p>release 预发布分支</p><p>github flow模型</p><p><img src="/images/typora-user-images/image-20240526135358109.png" alt="image-20240526135358109"></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2023/12/30/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/12/30/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ul><li><p>单体架构</p><ul><li><p>将所有功能几中在一个项目中开发 打包成一个包部署</p></li><li><p>架构简单 部署成本低</p></li><li><p>团队协作成本高</p></li><li><p>系统发布效率低  大型项目编译需要几十分钟 耗时长</p></li><li><p>系统可用性差</p></li><li><p><strong>适合开发功能简单 规模较小的项目</strong></p></li></ul></li><li><p>微服务</p><ul><li>把单体架构中的功能模块拆分成多个独立的项目</li><li>粒度小</li><li>团队自治</li><li>服务自治  每个服务对应 一个web服务器 一个数据库</li></ul></li></ul><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>集成了各种微服务功能组件 并基于SpringBoot实现了组件的自动装配 从而提供了良好的开箱即用体验</p><p>拆分目标 <strong>高内聚</strong> 每个微服务的职责尽量单一 包含业务相互关联度高 完整度高  <strong>低耦合</strong> 每个微服务功能相对独立 尽量减少对其他微服务的依赖</p><p>工程结构：</p><ul><li>独立project</li><li>maven聚合   一个project下好几个module</li></ul><p>远程调用</p><p><img src="/images/typora-user-images/image-20240727113255997.png" alt="image-20240727113255997"></p><p><code>@RequiredArgsContructor</code> 声明 final 的bean 能够自动注入 取消使用@Autowired注解使用</p><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p><strong>服务提供者</strong> 暴露服务接口 供其他服务调用</p><p><strong>服务消费者</strong> 调用其他服务提供的接口</p><p><strong>注册中心</strong> 记录并监控微服务各实例状态 推送服务变更信息（服务提供者的心跳机制）</p><p>提供者会在启动时注册自己信息到注册中心 消费者可以从注册中心订阅和拉取服务信息</p><p>提供者有多个实例时 消费者可以通过负载均衡算法 从多个实例中选择一个</p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>国内企业占比最多的注册中心组件 目前已加入到SpringCloudAlibaba</p><ol><li>配置Nacos数据表</li><li>doker部署</li><li>引入依赖</li><li>配置yml nacos地址</li><li>服务消费者： 调用 DiscoveryClient API <img src="/images/typora-user-images/image-20240727123451360.png" alt="image-20240727123451360"></li></ol><p>拉取实例列表 挑选一个实例 负载均衡 获取实例的ip</p><h3 id="OpenFegin"><a href="#OpenFegin" class="headerlink" title="OpenFegin"></a>OpenFegin</h3><p>声明式的http客户端  基于SpringMvC常见的注解 帮我们优雅的实现http请求的发送 </p><p><img src="/images/typora-user-images/image-20240727124448074.png" alt="image-20240727124448074"></p><ol><li>引入依赖 openfegin和loadbalance </li><li>开启注解</li><li>编写feignClient</li></ol><p><img src="/images/typora-user-images/image-20240727124914944.png" alt="image-20240727124914944"></p><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>openfeign对http请求做了伪装 底层发起http请求依赖于其他框架 默认为HttpURLConnection 不支持连接池 </p><p><em>HTTP连接池允许客户端重用TCP连接来发送多个HTTP请求，而不是为每个请求都创建一个新的TCP连接。这不仅可以减少TCP连接的建立和销毁的开销，还可以减少由于TCP握手和SSL&#x2F;TLS握手导致的延</em></p><p>openfegin整合okhttp的步骤</p><img src="/images/typora-user-images/image-20240727153309479.png" alt="image-20240727153309479" style="zoom:80%;" /><ul><li>引入依赖</li><li>配置文件开启连接池功能</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>微服务课程P52  ！！！！</p><p>方法一 <img src="/images/typora-user-images/image-20240727155951160.png" alt="image-20240727155951160" style="zoom:30%;" /></p><p>方法二<img src="/images/typora-user-images/image-20240727160037147.png" alt="image-20240727160037147" style="zoom:30%;" /></p><h4 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h4><p>声明类型为 Logger.Level的Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.level.FUll; <span class="comment">//四个级别</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@FeignClient或者@EnableFeignClient注解上声明 bean的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(configuration = DefaultFeignConfig.class)</span><br></pre></td></tr></table></figure><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网络的关口 负责请求的<strong>路由 转发 身份校验</strong></p><p><strong>SpringCloudGateway</strong></p><p>基于webFlux响应式编程</p><p>无需调优即可获得优异性能</p><h3 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h3><ol><li>创建新的模块</li><li>引入网关依赖</li><li>编写启动类</li><li>配置路由规则</li></ol><img src="/images/typora-user-images/image-20240727173046433.png" alt="image-20240727173046433" style="zoom:50%;" /><p><img src="/images/typora-user-images/image-20240727181510339.png" alt="image-20240727181510339"></p><p>路由过滤器</p><p><img src="/images/typora-user-images/image-20240727182410802.png" alt="image-20240727182410802"></p><p><img src="/images/typora-user-images/image-20240727183709992.png" alt="image-20240727183709992"></p><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><ul><li>GatewayFilter 路由过滤器 作用于任意指定的路由 默认不生效 要配置到路由后生效</li><li>GlobalFilter 全局过滤的</li></ul><h3 id="用户信息的传递"><a href="#用户信息的传递" class="headerlink" title="用户信息的传递"></a>用户信息的传递</h3><h4 id="网关传递到微服务"><a href="#网关传递到微服务" class="headerlink" title="网关传递到微服务"></a>网关传递到微服务</h4><p>首先在网关的登录校验过滤器中 把获取的用户写入请求头</p><p>拦截器里 获取到用户信息 然后保存到threadLocal里</p><h4 id="微服务之间传递用户信息"><a href="#微服务之间传递用户信息" class="headerlink" title="微服务之间传递用户信息"></a>微服务之间传递用户信息</h4><p>openfeign提供了一个拦截器的接口 RequestInterceptor</p><p><img src="/images/typora-user-images/image-20240729154450791.png" alt="image-20240729154450791"></p><p>提供header API 允许对请求头进行操作</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>微服务重复配置过多 维护成本高  业务配置经常变动 每次修改都要重启服务  网关路由配置写死 如果变更要重启网关  </p><h3 id="nacos-配置管理服务"><a href="#nacos-配置管理服务" class="headerlink" title="nacos 配置管理服务"></a>nacos 配置管理服务</h3><h4 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h4><ol><li>添加共享配置到nacos 包括jdbc mp 日志 swagger openfeign</li><li>基于nacosconfig拉取共享配置代替微服务的本地配置<img src="/images/typora-user-images/image-20240729182954077.png" alt="image-20240729182954077" style="zoom:50%;" /></li></ol><img src="/images/typora-user-images/image-20240729183013126.png" alt="image-20240729183013126" style="zoom:50%;" /><ol start="3"><li><p>添加依赖 自动配置bootstrap配置文件   </p></li><li><p>新建yaml文件 <img src="/images/typora-user-images/image-20240729183140971.png" alt="image-20240729183140971"></p></li></ol><h4 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h4><p>当修改配置文件中的配置时 微服务无序重启即可使配置生效</p><p>如 token时长 验证次数等等 需要修改 </p><ol><li>nacos中要有一个与微服务名有关的配置文件</li><li>微服务中要以特定的方式读取需要热更新的配置属性</li><li><img src="/images/typora-user-images/image-20240729184553673.png" alt="image-20240729184553673"></li><li>推荐使用第一种 添加@Bean注解</li></ol><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><h2 id="微服务保护和分布式事务"><a href="#微服务保护和分布式事务" class="headerlink" title="微服务保护和分布式事务"></a>微服务保护和分布式事务</h2><h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><p>微服务调用链路中的某个服务故障 引起整个链路中的所有微服务都不用</p><ul><li><strong>请求限流</strong> 限制微服务的请求的并发量</li></ul><p> 即qbs</p><ul><li><strong>线程隔离</strong>  限定每个业务能使用的线程数量而将故障业务隔离 避免一个业务将整个服务阻塞</li></ul><p>调节并发线程数 （5个并发线程 如果单线程qps为2 那么5线程的qps为10）</p><ul><li><strong>服务熔断</strong> 断路器统计请求的异常比例或慢调用比例 如果超出与之则会熔断该业务 拦截该接口的请求 所有请求快速失败 全都走fallback 逻辑</li></ul><p>将feignclient作为sentinel的簇点资源  配置文件开启 <code>feignclient.sentinel.enable:true</code></p><p>feignclient的fallback配置有两种方式 </p><ol><li>fallbackclass 无法对远程调用的异常做处理</li><li>fallbackfactory 可以对远程调用的异常做处理 <ul><li>自定义fallbackfactory <img src="/images/typora-user-images/image-20240730160001049.png" alt="image-20240730160001049"></li></ul></li></ol><p><img src="/images/typora-user-images/image-20240730160108903.png" alt="image-20240730160108903"></p><ul><li><strong>失败处理</strong> 定义fallback逻辑 让业务失败时不再抛出异常 而是返回默认数据或友好提示</li></ul><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>阿里巴巴开源的一款微服务流量控制组件</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>阿里巴巴和蚂蚁金服 共同设计的分布式事务的解决方案</p><ul><li>TC（transaction coordinator）事务协调者 维护全局和分支事务的状态 协调全局事务提交或回滚</li><li>TM （transaction manage) 事务管理器 定义全局事务的范围 开启全局事务 提交或回滚全局事务</li><li>RM（resource manager）资源管理器 管理分支事务 与TC交谈以注册分支事务和报告分支事务的状态</li></ul><p><img src="/images/typora-user-images/image-20240730163932495.png" alt="image-20240730163932495"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>高性能异步通讯组件</p><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><ul><li>时效性强 等待到结果才返回</li><li>扩展性差 性能下降 级联失败</li></ul><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><ul><li>解除耦合 扩展性强 无需等待 性能好 </li><li>故障隔离  下游服务故障不影响上游业务</li><li>缓存消息 流量削峰填补</li><li>不会得到结果 时效性差 业务安全依赖broker的可靠性</li></ul><h3 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h3><ul><li>RabbitMQ</li><li>ActiveMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p><img src="/images/typora-user-images/image-20240726101452651.png" alt="image-20240726101452651"></p><p>虚拟主机  数据隔离</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>基于AMQP Spring AMQP 操作rabbitMQ</p><ul><li>引入 Spring boot starter amqp依赖</li><li>配置yml 文件 添加 rabbitmq配置 host port virtual-host username password</li><li>注入 RabbitTemplate  调用api 发消息</li><li>添加注释 @RabbitListener 传入监听队列名称   方法参数存储接收的消息（spring自动进行消息与参数对象的转换）</li></ul><h3 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h3><p>任务模型 让多个消费者绑定到一个队列 共同消费队列中的消息</p><p><strong>消费者消息推送限制</strong></p><p>默认情况下 RabbitMQ会将消息依次轮询投递给绑定在队列上的消费者 但是这并没有考虑消费者是否已经处理完消息 可能会出现消费堆积 所以修改yml配置文件 设置preFetch为1 确保统一时刻最多投递给消费者1条消息</p><p>work<strong>模型的使用</strong></p><ul><li>多个消费者绑定到一个队列 可以加快消息处理速度</li><li>同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量 处理完一条在处理下一条 实现能者多劳</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>接收publisher发送的消息 将消息按照规则路由到与之绑定的队列</p><ul><li><p>Fanout 广播  将消息发送给所有队列</p></li><li><p>Direct 定向  将收到消息按照规则路由到指定的Queue</p><ul><li>每个Queue斗鱼Exchange设置一个BindingKey</li><li>发布者发送消息时 指定消息的RoutingKey</li><li>Exchange 将消息路由到BindingKey与消息RoutingKey一致的队列</li></ul></li><li><p>Topic 话题</p><ul><li>基于RoutingKey做消息路由 但是routingKey通常是多个单词的组合并且是以 <code>.</code> 分隔</li><li>Queue与Exchange指定BindingKey可以使用通配符  <code>#</code>代指0个或多个单词 <code>*</code>代指一个单词</li></ul></li></ul><h3 id="声明队列交换机"><a href="#声明队列交换机" class="headerlink" title="声明队列交换机"></a>声明队列交换机</h3><p>SpringAMQP提供了几个类 同于声明 队列 交换机 及其绑定关系</p><ul><li><p>Queue 声明队列  QueueBuilder</p></li><li><p>Exchange 声明交换机 ExchangeBuilder</p></li><li><p>Binding 声明交换机和队列的绑定关系 使用工厂类BindingBuilder构建</p></li></ul><p><strong>案例</strong></p><p>改造余额支付功能 不再同步调用支付服务的openfegin接口 而是采用异步MQ通知交易服务更新订单状态</p><p>一些边缘业务适合使用mq处理 更新订单状态 短信通知用户 增加用户积分</p><h2 id="RabbitMQ高级"><a href="#RabbitMQ高级" class="headerlink" title="RabbitMQ高级"></a>RabbitMQ高级</h2><p>消息可靠性问题 ·</p><h3 id="发送者可靠性"><a href="#发送者可靠性" class="headerlink" title="发送者可靠性"></a>发送者可靠性</h3><ul><li>发送者重连<ul><li>由于网络波动 可能会出现发送者发送MQ失败的情况 通过配置可以开启连接失败后的重连机制</li><li>但是SpringAMQP重连机制是阻塞式的重试 多次重连等待过程中 当前线程是被阻塞的 影响业务性能</li><li>对于有业务性能需求 建议禁用重试机制  当然也可以考虑使用异步线程来执行发送消息的代码</li></ul></li><li>发送者确认机制<ul><li>SpringAMQP提供了PublisherConfim和PublisherReturn两种确认机制 开启后 当发送者发送消息给MQ后 MQ会返回结果给发送者</li><li>消息投递到MQ 但是路由失败 返回 ACK</li><li>临时消息投递到MQ 并且入队成功 返回ACK</li><li>持久消息投递到MQ 并且入队完成持久化 返回ACK</li><li>其他情况返回NACK 告知投递失败</li><li>开启机制三种模式<ul><li>none 关闭</li><li>simple 同步阻塞等待MQ回执</li><li>correlated MQ异步回调方式返回回执消息</li></ul></li></ul></li></ul><h3 id="MQ可靠性"><a href="#MQ可靠性" class="headerlink" title="MQ可靠性"></a>MQ可靠性</h3><p>默认情况MQ会把消息存储在内存降低消息收发的延迟</p><p>一旦MQ宕机 内存中的消息会丢失  并且内存空间有限 当消费者故障或者处理过慢 会导致消息挤压</p><p><strong>开启数据持久化</strong> 会存入磁盘 但是会导致性能下降 无法应对高并发</p><h4 id="LazyQueue-惰性队列"><a href="#LazyQueue-惰性队列" class="headerlink" title="LazyQueue 惰性队列"></a>LazyQueue 惰性队列</h4><p>接收消息后直接存入磁盘不再存入内存 消费者要消费时才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存 最多2048条）</p><p>在3.12版本后 所有队列都是LazyQUeue模式无法更改</p><h3 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h3><h4 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h4><p>当消费者处理消息结束后 向MQ发送一个回执 告知MQ自己消息处理的状态</p><ul><li>ack 成功处理消息 MQ从队列中删除消息</li><li>nack  消息处理失败 MQ再次投递消息</li><li>reject 消息处理失败并拒绝该消息 MQ从队列中删除该消息</li></ul><p>springAMQP实现了消息确认机制 配置文件开启</p><ul><li>none 不处理 消息投递之后立刻ack 消息从mq中删除</li><li>manual 手动模式 需要自己在业务代码中调用api 发送ack或者reject 存在业务入侵 但灵活</li><li>auto 自动模式 SpringAMQP利用AOP对消息处理逻辑做了环绕增强 当业务正常时自动返回ack<ul><li>业务异常 自定返回nack</li><li>消息处理或校验异常 返回reject</li></ul></li></ul><h4 id="消费者失败重试机制"><a href="#消费者失败重试机制" class="headerlink" title="消费者失败重试机制"></a>消费者失败重试机制</h4><p>配置文件开启重试机制 如果重试次数达到上限 则需要MessagesRecoverer接口来处理 包含三种不同的实现：</p><ul><li>RejectAndDontRequeueRecoverer 重试次数耗尽后 直接reject 丢弃消息 默认该方法</li><li>ImmediateRequeueMessageRecoverer 重试次数耗尽后 返回nack 消息重新入队</li><li>RepublishMessageRecoverer 重试后 将失败的消息投递到指定的交换机</li></ul><h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h4><p><code>f(f(x))=f(x)</code>在程序开发中 指同一个业务 执行一次或多次对业务的状态的影响是一致的</p><h5 id="唯一消息id"><a href="#唯一消息id" class="headerlink" title="唯一消息id"></a>唯一消息id</h5><h6 id="给每个消息都设置一个唯一id-liyongid区分是否是重复消息"><a href="#给每个消息都设置一个唯一id-liyongid区分是否是重复消息" class="headerlink" title="给每个消息都设置一个唯一id liyongid区分是否是重复消息"></a>给每个消息都设置一个唯一id liyongid区分是否是重复消息</h6><ol><li>每一条消息都生成一个唯一的id 与消息一起投递给消费者</li><li>消费者接收后处理自己的业务 业务处理成功后将消息id存入数据库</li><li>下次收到同样的消息 数据库查询是否存在</li></ol><p><img src="/images/typora-user-images/image-20240807143141817.png" alt="image-20240807143141817"></p><h5 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h5><h6 id="结合业务逻辑-基于业务本身做判断"><a href="#结合业务逻辑-基于业务本身做判断" class="headerlink" title="结合业务逻辑 基于业务本身做判断"></a>结合业务逻辑 基于业务本身做判断</h6><p>面试题：如何确保支付服务和交易服务之间的订单状态一致性</p><ul><li>首先支付服务会在用户支付成功后利用MQ通知交易服务 完成订单状态同步</li><li>其次 为了保证MQ消息可靠性 我们采用生产者确认机制 消费者确认 消费者失败重试等策略 确保消息投递和处理的可靠性 同时也开启了MQ的持久化 避免因为服务宕机导致消息丢失</li><li>左后我们还在交易服务更新订单状态时做了业务幂等判断 避免因为重复消息导致订单状态异常</li></ul><h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>在网络异常等特殊情况</p><p>发送者发送消息指定一个时间 消费者不会立刻收到消息 而是在指定时间后才收到消息</p><p><img src="/images/typora-user-images/image-20240807144837853.png" alt="image-20240807144837853"></p><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>死信：</p><ul><li>消费者使用reject或者nack声明消费失败 并且消费的requere参数设置为false</li><li>消息是一个过期消息（达到了队列或消息本身设置的过期时间）超时无人消费</li><li>要投递的队列消息堆积满了 最早的消息可能成为死信</li></ul><p>如果队列通过dead-letter-exchange 属性制定了一个交换机 那么该队列中的死信就会投递到这个交换机中 这个交换机成为死信交换机 </p><p><img src="/images/typora-user-images/image-20240807195123756.png" alt="image-20240807195123756"></p><h4 id="延迟消息插件"><a href="#延迟消息插件" class="headerlink" title="延迟消息插件"></a>延迟消息插件</h4><p>将普通交换机改为支持延迟消息功能的交换机 当消息投递到交换机可以暂存一定时间 到期后再投递到队列</p><h4 id="取消超时订单"><a href="#取消超时订单" class="headerlink" title="取消超时订单"></a>取消超时订单</h4><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring-Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2023/12/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/12/30/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>面向无连接协议 速度夸 有大小限制一次最多64k 数据不安全 易丢失数据</p><p>在线视频 网络通话</p><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><ul><li>创建发送端的DatagramSocket对象<ul><li>参数传递 端口号</li></ul></li><li>数据打包<ul><li>DatagramPackage</li></ul></li><li>发送资源</li><li>释放资源</li></ul><p><img src="/images/typora-user-images/image-20240601212258135.png" alt="image-20240601212258135"></p><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><ul><li>创建接收端的DatagramSocket对象<ul><li>一定要绑定端口</li></ul></li><li>接收打包好的数据<ul><li>程序在此是阻塞的一直等待直到接收到数据</li><li>receive 创建接收包 传递数组</li></ul></li><li>解析数据包</li><li>释放资源</li></ul><img src="/images/typora-user-images/image-20240601212806756.png" alt="image-20240601212806756" style="zoom:100%;" /><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>单播</p><p>组播 对象创建 MulticastSocket 接收端 划定组播地址 发送端 确定组播地址 </p><p>广播  255.255.255.255</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>面向连接通信协议 速度慢 没有大小限制 数据安全</p><p>下载软件 文字聊天 发送邮件</p><p>两端个建立socket对象 通过io流来产生通信 </p><p><img src="/images/typora-user-images/image-20240601215021912.png" alt="image-20240601215021912"></p><p>中文乱码问题 <img src="/images/typora-user-images/image-20240601215838990.png" alt="image-20240601215838990"></p><p>字节流转化成字符流</p><p>三次握手 保证建立连接</p><p>四次挥手 确保连接断开 且数据处理完毕</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> UDP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus框架</title>
      <link href="/2023/12/20/MybatisPlus/"/>
      <url>/2023/12/20/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h1><p>配置poml文件</p><p>导入plus坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入druid坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置属性文件 后缀改yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dao类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">userDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;user&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分页查询</p><p><code>IPage page =new Page()</code></p><p>selectPage方法</p><p>数据存放在了page对象中</p><p>getRecords 数据</p><p>需要配置拦截器</p><p><img src="/images/typora-user-images/image-20240309161730865.png" alt="image-20240309161730865"></p><p><img src="/images/typora-user-images/image-20240309161752073.png" alt="image-20240309161752073"></p><p>条件查询</p><p><img src="/images/typora-user-images/image-20240309162233396.png" alt="image-20240309162233396"></p><p>属性名避免写错</p><p><img src="/images/typora-user-images/image-20240309162346513.png" alt="image-20240309162346513"></p><p>简化第二种方式</p><p><img src="/images/typora-user-images/image-20240309162447385.png" alt="image-20240309162447385"></p><p>或者 条件</p><p><img src="/images/typora-user-images/image-20240309162652144.png" alt="image-20240309162652144"></p><p>条件查询 null值处理</p><p>不推荐</p><p><img src="/images/typora-user-images/image-20240309163306410.png" alt="image-20240309163306410"></p><p>推荐</p><p><img src="/images/typora-user-images/image-20240309163334476.png" alt="image-20240309163334476"></p><p>查询投影</p><p><img src="/images/typora-user-images/image-20240309163732491.png" alt="image-20240309163732491"></p><p>查询条件</p><p><img src="/images/typora-user-images/image-20240309164237748.png" alt="image-20240309164237748"></p><ul><li>lt</li><li>le</li><li>gt</li><li>ge</li><li>eq</li><li>between</li></ul><p>模糊匹配</p><p>likeLeft</p><p>likeRight</p><p>映射</p><p><img src="/images/typora-user-images/image-20240309164526274.png" alt="image-20240309164526274"></p><p>编码中出现了数据库中未定义的属性</p><p><img src="/images/typora-user-images/image-20240309164624633.png" alt="image-20240309164624633"></p><p>设置相关字段不参与查询</p><p><img src="/images/typora-user-images/image-20240309165201618.png" alt="image-20240309165201618"></p><p>表名与编码开发设计不同步</p><p><img src="/images/typora-user-images/image-20240309165255825.png" alt="image-20240309165255825"></p><p>id生成策略</p><p><img src="/images/typora-user-images/image-20240309165808736.png" alt="image-20240309165808736"></p><p>雪花算法</p><p><img src="/images/typora-user-images/image-20240309165927608.png" alt="image-20240309165927608"></p><p><img src="/images/typora-user-images/image-20240309170032765.png" alt="image-20240309170032765"></p><p>或者</p><p><img src="/images/typora-user-images/image-20240309170108446.png" alt="image-20240309170108446"></p><p>多记录</p><p>deleteBatchIds</p><p>selectBatchIds</p><p>逻辑删除</p><p>设置逻辑删除字段</p><p>库里添加字段</p><p>实体类配置</p><p><img src="/images/typora-user-images/image-20240309171436655.png" alt="image-20240309171436655"></p><p>或者pom</p><p><img src="/images/typora-user-images/image-20240309171531491.png" alt="image-20240309171531491"></p><p>乐观锁</p><p>数据库添加字段</p><p>实体类添加注解</p><p><img src="/images/typora-user-images/image-20240309172355795.png" alt="image-20240309172355795"></p><p>添加拦截器</p><p><img src="/images/typora-user-images/image-20240309172419488.png" alt="image-20240309172419488"></p><p>代码生成器</p><p><img src="/images/typora-user-images/image-20240309172906089.png" alt="image-20240309172906089"></p><p><img src="/images/typora-user-images/image-20240309173727804.png" alt="image-20240309173727804"></p><p><img src="/images/typora-user-images/image-20240309173744144.png" alt="image-20240309173744144"></p><p><img src="/images/typora-user-images/image-20240309173754659.png" alt="image-20240309173754659"></p><p><img src="/images/typora-user-images/image-20240309173803505.png" alt="image-20240309173803505"></p><p><img src="/images/typora-user-images/image-20240309173811929.png" alt="image-20240309173811929"></p><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>只需要修改配置文件 既可以正常调用mp提供的delete get方法</p><p><img src="/images/typora-user-images/image-20240531223649110.png" alt="image-20240531223649110"></p><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><p>仅作为避免循环依赖使用</p><p>查询 多表查询</p><p>只使用Service层会导致循环注入 所以可以使用静态工具</p><p> <img src="/images/typora-user-images/image-20240531223340742.png" alt="image-20240531223340742"></p><h2 id="枚举处理器"><a href="#枚举处理器" class="headerlink" title="枚举处理器"></a>枚举处理器</h2><p><img src="/images/typora-user-images/image-20240531224647843.png" alt="image-20240531224647843"></p><p>mybatis中提供ibatis包 </p><p>使用注解@EnumValue  然后添加枚举处理器</p><p><img src="/images/typora-user-images/image-20240531225022239.png" alt="image-20240531225022239"></p><p>返回值默认返回枚举 昵称 添加@JsonValue 可选返回value或者dsc</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>配置文件开启 <code>rewriteBatchedStatements=true</code></p><p>普通for循环逐条插入速度极差 不推荐</p><p>MP默认批处理 基于预编译批处理 仅仅是批量提交</p><p>配置jdbc参数 驱动会自动把一条条的语句重写成一条语句</p><h2 id="json处理器"><a href="#json处理器" class="headerlink" title="json处理器"></a>json处理器</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="/2023/12/15/SpringMVC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/15/SpringMVC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>表现层框架技术 用于表现层开发</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>网页调试与发送网页HTTP请求的CHrome插件</p><p>常用于进行接口测试</p><h2 id="Apifox"><a href="#Apifox" class="headerlink" title="Apifox"></a>Apifox</h2><p>集Postman Swagger Mock  JMeter于一体</p><h2 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h2><p>在类上面定义请求路径前缀 <code>@RequestMapping(&quot;/user&quot;)</code></p><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><ul><li><p>普通参数</p></li><li><p>POJO参数  请求参数名与形参对象属性名相同 定义POJO类型形参即可接收</p></li><li><p>POJO嵌套  POJO对象包含POJO对象</p></li><li><p>数组参数  同样的变量名</p></li><li><p>集合参数  @RequestParam</p></li></ul><h2 id="接受请求中的json数据"><a href="#接受请求中的json数据" class="headerlink" title="接受请求中的json数据"></a>接受请求中的json数据</h2><ol><li>配置坐标  </li><li>设置发送json数据 Body-raw-json</li><li>开启自动转换数据的支持 @EnableWebMvc</li><li>设置接收json数据  @RequestBody</li></ol><h2 id="RequestBody-与-RequestParam"><a href="#RequestBody-与-RequestParam" class="headerlink" title="@RequestBody 与 @RequestParam"></a>@RequestBody 与 @RequestParam</h2><p>区别  </p><p>param用于接受url地址  表单传参 application&#x2F;x-www-form-urlencoded</p><p>body用于接收json数据 application&#x2F;json</p><p>应用后期 发送json数据为主 body应用广泛</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><ul><li><h4 id="响应页面-跳转界面"><a href="#响应页面-跳转界面" class="headerlink" title="响应页面 跳转界面"></a>响应页面 跳转界面</h4></li></ul><p>返回值 String <code>retrun&quot;page.jsp&quot;;</code></p><ul><li><h4 id="响应文本数据"><a href="#响应文本数据" class="headerlink" title="响应文本数据"></a>响应文本数据</h4></li></ul><p>返回值 String  添加注释 @ResponseBody <code>return &quot;response txt&quot;;</code></p><ul><li><h4 id="响应POJO对象"><a href="#响应POJO对象" class="headerlink" title="响应POJO对象"></a>响应POJO对象</h4></li></ul><p>返回值 对象类型 添加注释 @ResponseBody <code>return 对象;</code></p><ul><li><h4 id="响应集合"><a href="#响应集合" class="headerlink" title="响应集合"></a>响应集合</h4></li></ul><p>返回值 集合类型 </p><p>@ResponseBody(类型转换器 HttpMessageConverter)</p><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h2><p>（表现形式状态转换）  </p><p>隐藏资源的访问行为 无法通过地址得知对资源是何种操作 书写简化</p><p>用REST风格对资源进行访问称为RESTfull</p><p>常用标准动作  GET POST PUT DELETE</p><p>指定请求行为  <code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p><p>如果需要传参数 形参添加注释<code>@pathVariable   </code> 路径添加 <code>/&#123;参数名&#125;</code></p><h3 id="RESTfull快速开发"><a href="#RESTfull快速开发" class="headerlink" title="RESTfull快速开发"></a>RESTfull快速开发</h3><p>@RequestMapping 可根据具体请求操作更改 @PostMapping  @GetMapping 等等</p><p>@Contoller与@ResponseBody合并为 @RestController    @RequestMapping(“公共前缀”)</p><h3 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h3><p>动态拦截方法调用的机制 </p><ul><li>在指定的方法调用前后执行预定设定的代码</li><li>阻止原始方法执行</li></ul><p><img src="/images/typora-user-images/image-20240511211135638.png" alt="image-20240511211135638"></p><p>拦截器与过滤器</p><p>归属不同 ：Filter属于servlet技术 Interceptor属于SpringMVC技术</p><p>拦截内容不同  Filter对所有访问进行增强 Interceptor仅对SpringMVC的访问进行增强</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springMVC </tag>
            
            <tag> Spring-Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2023/12/06/MySQL/"/>
      <url>/2023/12/06/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础篇学习"><a href="#MySQL基础篇学习" class="headerlink" title="MySQL基础篇学习"></a>MySQL基础篇学习</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><img src="/images/typora-user-images/image-20240513204901071.png" alt="image-20240513204901071"></p><h3 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h3><ol><li>属性 c 常规 包含目录 server include</li><li>链接器 常规 附加库目录 server lib</li><li>输入 依赖库 libmysql&#x2F;lib</li></ol><p>命令行操作数据库</p><p><code>mysql -u root -p</code></p><p>要先<code>net start mysql80</code>启动数据库服务器</p><h3 id="MYSQL数据类型"><a href="#MYSQL数据类型" class="headerlink" title="MYSQL数据类型"></a>MYSQL数据类型</h3><ul><li><p>tinyint 小整数值 </p></li><li><p>smallint 大整数数值</p></li><li><p>float 单精度浮点数值</p></li><li><p>double 双精度浮点数值</p></li><li><p>char 定长字符串</p></li><li><p>varchar 变长字符串</p></li><li><p>tinytext 短文本字符串</p></li><li><p>data 日期值 YYYY-MM-DD</p></li><li><p>time 时间值或持续时间值   HH：MM：SS</p></li><li><p>year 年份值 YYYY</p></li></ul><h2 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul><li><p>查询所有数据库 <code>SHOW DATABASES;</code></p></li><li><p>查看当前数据库 <code>SELECT DATABASE();</code></p></li><li><p>创建数据库 <code>CREATE DATABASE [IF EXISTIS]数据库名 [DEFAULT CHARSET 字符集] ;</code></p></li><li><p>删除数据库 <code>DROP DATABASE[IF EXISTS] 数据库名;</code></p></li><li><p>切换数据库 <code>USE 数据库名;</code></p></li><li><p>查询当前数据库所有表 <code>SHOW TABLES；</code></p></li></ul><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul><li><p>查询表结构 <code>DESC 表名；</code></p></li><li><p>查询创建表语句 <code>SHOW CREATE TABLE 表名；</code></p></li><li><p>创建表 <code>CREATE TABLE 表名（字段 字段类型 [COMMENT 注释]）[COMMENT 注释]；</code></p></li><li><p>删除表 <code>DROP TABLE 表名；</code></p></li><li><p>删除表内容 <code>TRUNCATE ；</code></p></li><li><p>修改表名 ALTER TABLE 表名 RENAME TO 新表名</p></li></ul><h3 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h3><ul><li><p>修改字段 <code>ALTER TABLE 表名 ADD 字段名 类型（长度）[COMMENT 注释]；</code></p></li><li><p>修改字段数据类型 <code>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度）；</code></p></li><li><p>修改数据类型和字段名称 <code>ALTER TABLE 表明 CHANGE 旧字段名 新字段名 新类型（长度）[COMMENT 注释]；</code></p></li><li><p>删除字段 <code>ALTER TABLE 表名 DROP 字段名；</code></p></li></ul><h2 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML  数据操作语言"></a>DML  数据操作语言</h2><h4 id="添加数据-INSERT"><a href="#添加数据-INSERT" class="headerlink" title="添加数据 INSERT"></a>添加数据 INSERT</h4><p><code>INSERT INTO 表名（字段）VALUES(值)；</code></p><h4 id="修改数据-UPDATA"><a href="#修改数据-UPDATA" class="headerlink" title="修改数据 UPDATA"></a>修改数据 UPDATA</h4><p><code>UPDATA 表名 SET 字段名=值 [WHERE 条件]；</code></p><h4 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据 DELETE"></a>删除数据 DELETE</h4><p><code>DELETE FROM 表名 WHERE 条件；</code></p><h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h2><ul><li><p>SELECT 字段列表</p></li><li><p>FROM 表名列表</p></li><li><p>WHERE 条件列表</p><ul><li><p>in 在其中之一</p></li><li><p>not like </p><ul><li><p>%表示任何字符出现任意次数</p></li><li><p>_表示单个字符</p></li><li><p>[]表示一个字符集</p></li></ul></li></ul></li><li><h2 id="GROUP-BY-分组字段列表"><a href="#GROUP-BY-分组字段列表" class="headerlink" title="GROUP BY 分组字段列表"></a>GROUP BY 分组字段列表</h2></li><li><p>HAVING 分组后条件列表</p></li><li><p>ORDER BY 排序字段列表</p><ul><li><p>字段 默认升序 加 DESC 是降序</p></li><li><p>between   and  前闭后闭</p></li></ul></li><li><p>LIMIT 分页参数</p><ul><li>limit 起始索引 每页展示记录数</li></ul></li><li><p>DISTINCT 数据去重</p></li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li><p>一对多</p><ul><li><p>部门 – 员工</p></li><li><p>多的一边建立外键，指向另一方的主键</p></li><li><p>多对多</p><ul><li>学生 – 课程</li><li>中间表，至少两个外键分别关联两个主键</li></ul></li><li><p>一对一 </p><ul><li>用户 用户详情</li><li>任意一方加入外键 设置外键为唯一约束 UNIQUE</li></ul></li><li><p>笛卡尔查询</p><ul><li>两张表所有组合情况</li><li>消除  WHERE 表名.字段 &#x3D; 表名.字段</li></ul></li><li><p>内连接 相当于查询A，B交集部分数据</p><ul><li>隐式内连接<ul><li>SELECT 字段列表 FROM 表1，表2 WHERE；</li></ul></li><li>显式内连接·<ul><li>SELECT 字段列表 FROM 表1【INNER】JOIN 表2 ON 连接条件</li></ul></li></ul></li><li><p>外连接  </p><ul><li>左外连接<ul><li>SELECT 字段列表 FROM 表1 LEFT【OUTER】JOIN 表2 ON 条件</li></ul></li><li>右外连接<ul><li>SELECT 字段列表 FROM 表1 RIGHT 【OUTER】JOIN 表2 ON条件</li></ul></li></ul></li><li><p>自连接 </p><ul><li>当前表与自身连接查询 必须使用表别名</li><li>SELECT 字段列表 FROM 表1 别名A JOIN 表1 别名B ON 条件</li></ul></li></ul></li></ul><h2 id="DCL-数据库权限"><a href="#DCL-数据库权限" class="headerlink" title="DCL 数据库权限"></a>DCL 数据库权限</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ul><li>查询用户 </li><li><ul><li>USE mysql；</li><li>SELECT *FROM user；</li></ul></li><li>创建用户</li><li><ul><li>CREATE USER 用户名@主机名 IDENTIFIED BY密码；</li></ul></li><li>修改用户密码<ul><li>ALTER USER 用户名@主机名 INENTIFIED 原密码 BY 新密码；</li></ul></li><li>删除用户<ul><li>DROP USER 用户名@主机名；</li></ul></li><li>任意主机名 %</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li>主键 PRIMARY KEY</li><li>自动增长 AUTO_INCREMENT</li><li>不为空 NOT NULL</li><li>唯一 UNIQUE</li><li>默认为1 DEFAULT</li></ul><p>外键约束</p><p>ALTER TABLE 表名 ADD CONSITRINT 外键名称 FOREIGN KEY （外键字段名）REFERENCES 主表（主表列名）</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><img src="/images/typora-user-images/image-20240531232254682.png" alt="image-20240531232254682"></p><p>字符串截取 substring（字符串，起始位置，截取字符数）</p><p>字符串拼接 concat （字符串1，字符串2……）</p><p>字母大写 upper（字符串）</p><p>DATE_FORMAT(NOW(), ‘%d&#x2F;%m&#x2F;%Y’) AS formatted_date;</p><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p><img src="/images/typora-user-images/image-20240531232929533.png" alt="image-20240531232929533"></p><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p><img src="/images/typora-user-images/image-20240531233054277.png" alt="image-20240531233054277"></p><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p><img src="/images/typora-user-images/image-20240531233343351.png" alt="image-20240531233343351"></p><h1 id="进阶篇学习"><a href="#进阶篇学习" class="headerlink" title="进阶篇学习"></a>进阶篇学习</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>体系结构</p><ul><li>连接层 </li><li>服务层</li><li>引擎层</li><li>存储层</li></ul><p>存储引擎 表类型 </p><p>查看引擎 查看建表语句</p><p>指定存储引擎 ENGINE </p><p>SHOW  engins  </p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>默认存储引擎</p><ul><li>遵循ACID模型 支持<strong>事务</strong></li><li><strong>行级锁</strong> 提高并发访问性能</li><li>支持<strong>外键</strong> FOREIGN KEY约束 保证数据完整性和正确性</li></ul><p>对应文件 xxx.ibd  表空间文件{结构 数据 索引}</p><p><img src="/images/typora-user-images/image-20240223113432741.png" alt="image-20240223113432741"></p><p>应用：对事务完整性比较高 在并发条件下要求数据的一致性</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>早期默认存储引擎</p><ul><li>不支持事务 不支持外键</li><li>支持表锁 不支持行锁</li><li>访问速度快</li></ul><p>xxx.MYD（数据）  xxx.MYI （索引）      xxx.sdi(表结构)</p><p>应用：数据操作以读取和插入为主 很少更新或删除 对事务完整性并发性瑶琴斌不是很高</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>存储在内存 只能作为临时表或缓存使用</p><ul><li>内存存放</li><li>hash索引（默认）</li></ul><p>应用：临时表或缓存  对表的大小有限制</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>帮助mysql高效获取数据的数据结构</p><p>无索引  全表扫描 </p><p>索引</p><ul><li>优点  调高检索效率  </li><li>缺点 降低增删改的效率</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>在存储引擎层实现 不同引擎存储不同结构</p><ul><li>B+Tree索引  默认</li><li>Hash索引</li><li>R-Tree 空间索引</li><li>FUll-text 全文索引</li></ul><h4 id="B树-多路平衡查找树"><a href="#B树-多路平衡查找树" class="headerlink" title="B树  多路平衡查找树"></a>B树  多路平衡查找树</h4><p><strong>度数</strong> 一个节点子节点的个数  每个节点最多存储n个指针 n-1个值</p><p>B+树  </p><ul><li>所有元素都会出现在叶子节点 </li><li>叶子节点形成一个单向链表</li></ul><p><strong>在mysql中 优化了B+树</strong> 增加一个指向相邻叶子节点的链表指针 形成了带有顺序指针的b+树 提高区间访问性能</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul><li>不支持范围查找</li><li>无法利用索引进行排序</li><li>哈希冲突 使用链表解决</li><li>查询效率高 只需要查询一次 通常高于B+树</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul><li>主键索引  primary</li><li>唯一索引  uniquee</li><li>常规索引 快速定位数据</li><li>全文索引  fulltext</li></ul><p>innodb存储引擎 根据索引存储形式分为</p><p><strong>聚焦索引</strong>： 将数据存储与索引放到了一起 索引结构的叶子节点保存了<strong>行数据</strong> 必须有而且只有一个</p><p><strong>二级索引</strong> ：数据与索引分开存储 索引结构的叶子节点关联的是对应的<strong>主键</strong></p><p><strong>回表查询</strong>：先走二级索引找到主键值 然后走聚焦索引找到row</p><p><strong>创建索引：</strong><code>create [unique | fulltext] index index_name on table_name (index_col_name...);</code></p><p>一个索引关联多个字段 称为 联合索引</p><p><strong>查看索引：</strong> <code>SHOW index from table_name</code></p><p><strong>删除索引：</strong> <code>DROP index index_name on table_name</code></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li><p>明确 sql 执行频率 增删改查所占的频率</p><p><code>show [session|globale] sattus like &#39;com_______&#39;;</code>服务器状态信息</p></li><li><p><strong>慢查询日志</strong></p><ul><li>记录所有执行时间超过指定参数的sql语句的日志</li><li>慢查询日志默认没有开启 需要在配置文件配置 <code>/etc/my.cnf</code> 添加 <code>slow_query_log=1</code> <code>long_query_time=2</code></li><li>查询是否开启 <code>show variables like &#39;slow_query_log&#39;;</code></li><li>只会记录超过预定时间的操作才回记录</li></ul></li><li><p>profile 详情</p><ul><li><code>show profiles</code> 查看耗时都去了哪里</li><li><code>SELECT @@have_profiling</code>参数查看是否支持profile操作</li><li><code>set profiling=1</code>开启</li><li>查看指定query_id 的sql语句各个阶段的耗时 <code>show profile for query_id;</code></li><li>查看cpu使用情况 <code>show profile cpu for query_id</code></li></ul></li><li><p>explain执行计划</p><ul><li>在任意select语句之前添加关键字 <code>explain</code></li><li>id 表示查询语句中执行select自居或者是操作表的顺序 id相同 按照从上往下执行  如果不同 数值越大先执行</li><li>select_type  表示select的类型 simple（简单查询）primary（主查询 外层查询） union（union中的第二个或者后面的查询语句）subquery（select&#x2F;where 之后包含了子查询）</li><li>type 连接类型</li><li>pssible_key 显示可能应用在这张表上的索引</li><li>key 实际使用的索引</li><li>key_len 索引中使用的字节数</li><li>rows 预估值 执行查询的行数</li><li>filtered 行数占需要读取的行数的百分比</li></ul></li></ul><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><ul><li>最左前缀法则</li></ul><p>出现了联合索引 从索引的最左列开始查询 并且不跳过索引中发的列</p><ul><li>索引列运算</li></ul><p>不要在索引列上进行运算 索引将失效</p><ul><li>字符串索引添加引号</li></ul><p>否则索引将失效</p><ul><li>模糊查询</li></ul><p>尾部模糊 不会失效  头部模糊 索引失效</p><ul><li>or连接条件</li></ul><p>or前条件中有索引 后面没有索引 那么涉及的索引不会用到</p><ul><li>覆盖索引</li></ul><p>查询使用了索引 并且需要返回的列 在该索引中已经全都被找到</p><p>出现 using index condition 使用了索引 但是需要回表查询</p><p>出现 using where using index 使用了索引 不需要回表查询</p><ul><li>前缀索引</li></ul><p>只将字符串的前缀简历索引 大大节约索引空间 提高索引效率</p><p>例如 <code>create index index_name on table_name(ziduan(前缀个数));</code></p><ul><li>单列索引 联合索引</li></ul><p>如果存在多个查询条件 考虑针对查询字段简历索引时 建立联合索引</p><p>索引设计原则</p><p><img src="/images/typora-user-images/image-20240530202732559.png" alt="image-20240530202732559"></p><p><img src="/images/typora-user-images/image-20240530203203363.png" alt="image-20240530203203363"></p><p>数组比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
